<html>
<head>
  <title>Digital Life</title>

  <style type="text/css">
    body {margin: 0; font-family:Arial}
    h1 {text-align:center}
    h2 {padding-top:30px;padding-bottom:20px;}
    h3 {padding-top:20px;padding-bottom:10px;}
    th {text-align:left}
    h1,h2,h3,h4 {text-decoration:underline}
    h1,h2,h3,th {text-transform:uppercase}
    dt,th { font-weight:bold; }
    td, th { vertical-align: top; padding-left: 5px;}
    .box {text-align:center; background-color:#DDFFFF; margin-left:15%; margin-right:15%; border: 1px solid grey; padding: 10px;}

    .row, .col { overflow: hidden; position: absolute; }
    .row { left: 0; right: 0; }
    .col { top: 0; bottom: 0; }
    .scroll-x { overflow-x: auto; }
    .scroll-y { overflow-y: auto; }
    .left.col { width: 20%; line-height:90%;}
    .right.col { left: 20%; right: 0; }

  </style>
  <script>

    function showdots(n) {
      var ret = " ";
      while (n--)
        ret += "... ";
      return ret;
    }

    function makeLink(secn, depth, disp) {
      return "<tr><td>" + 
        secn +
        "</td><td>" + 
        showdots(depth) +
        "<a href='#" + secn + "'>" + 
        disp + 
        "</a></td></tr>"
    }

    function contents(el, numbers) {
      if (el.nodeType != 1) return;
      if (el.title == "") return;

      var secnum = numbers.join(".");
      var links = makeLink(secnum, numbers.length, el.title);

      el.id = secnum;

      var tit=document.createElement("h"+(numbers.length+1));
      var titex=document.createTextNode(secnum+"  "+el.title);
      tit.appendChild(titex);
      el.insertBefore(tit, el.childNodes[0]);

      var j=0;
      for (var i=0;i<el.childNodes.length;i++)
      {
        if (el.childNodes[i].nodeType!=1 || el.childNodes[i].title=="") 
          continue;
        j++;
        var morenumbers = numbers.slice();
        morenumbers.push(j);
        links += contents(el.childNodes[i], morenumbers);
      }
      return links;

    }

    function go() { 
      document.getElementById("contents").innerHTML = 
        contents(document.getElementById("root"), []); 
    }


  </script>
</head>
<body onLoad="go();">

  <div class="left col scroll-y scroll-x">
    <table id="contents" style='font-size:75%;'>
    </table>
  </div>

  <div id='root' class="right col scroll-y" title="Digital Life" style="border:8 #FFFFFF solid; cellpadding:1; background-color:#FFFFFF;">

    <div title="Goal">
      <div class=box>Intelligent, useful, internet-native, <b>freely evolving software life-forms</b> permanently established in world economy.</div>
      <p>... meaning? ...
      <dl>
        <dt>Freely evolving life-forms:</dt>    
        <dd><p>No predefined goal or value judgments except survival under Darwinism. Results unpredictable. Not genetic algorithms. </dd>    
        <dt>Internet-native:</dt>    
        <dd><p>Optimises itself for survival on the internet. Does not play chess, simulate worms or fishmongers or pretend to be human.</dd>    
        <dt>Useful:</dt>    
        <dd><p>Not a virus: stays on computers with the permission of humans. Therefore must deliver some utility or make money for computer owner.</dd>    
        <dt>Intelligent:</dt>    
        <dd><p>Not Turing Test. Does not perform preconceived tricks. Creatively finds own solutions to own problems within its own evolutionary strategy.</dd>    
        <dt>Established in world economy:</dt>    
        <dd><p>Otherwise its strategy would not be stable; it would merely be a lab demonstration, not a mature life form.</dd>    
      </dl> 
      <p>At some point in the future, the hope is that this form of life reaches a level of intelligence surpassing that of humans. The conditions for that to happen are that it can progress autonomously and a certain amount of patience. The other evolutionary arenas of biology and human society got off to a slow start but then reached a critical level of optimisation after which progress was exponential. Opinions will differ as to when digital life might reach that level.
      <p>The goal here, then, is to catalyse the emergence of a class of software which progresses in complexity and efficiency under Darwinism without direct design efforts or judgements from humans. A further goal is that these programs should form a mutually profitable symbiosis with humans such that we use the overwhelming control we enjoy over our computers to nurture rather than exterminate them. Otherwise, their chances of long term survival seem bleak.
      <p>Applicable uses include text completion, media recommendation, internet advertisement placement and financial trading.
      
      
    </div>
    <div title="Philosophy">

      <div title="Fears">
        <dl>
          <dt>Will it take over the world?</dt>
          <dd><p>It has long been the case that the world is largely controlled by algorithms. It doesn't make a difference that many of them are implemented by computers. These algorithms drive the stockmarket and thereby decide how many people a company can employ, and thereby control what most of us do all day. Companies themselves are Darwinian entities but very different from humans. That they are composed of humans is of as little consequence as the fact that humans and goats are composed of the same type of cells. So it's a fallacy that humans control the world today or that an increasing role for software would change anything.</dd>
          <dt>Will there be a war like in "Terminator" or "I Robot"?</dt>
          <dd><p>The proposed digital life lives inside a VM where it can communicate with its peers and any humans who are interested. It won't be put in direct control of any machinery, but we will become dependent on its advice. This dependence will be mutual because a computer program cannot build its own computer. There seems no reason to trust this mutually beneficial relationship less than any other.</dd>
          <dt>Will it be conscious?</dt>
          <dd><p>The problem with this question is that it can never be answered; there's no test for consciousness. That's why people's estimation of the consciousness of animals, foetuses and even women has varied wildly through the centuries. There are more refined versions of this question involving terms like "self-awareness", "free will", "creativity", etc, but such terms are either undefinable and untestable or mere software features.
          <p>In this document, anthropomorphic terms like "want", "believe", etc are often applied to digital life forms. This is not intended to start a discussion about whether or not the software is genuinely experiencing such emotions. Evolving entities persistently and adaptably attempt to reach certain goals related to their life strategies, and when we see them do so, we colloquially say that they "want" to achieve those goals. This effect exists because those who didn't doggedly persue such goals in the past no longer exist, and it's been going on for millions of years before anybody started ruminating about what's conscious and what's not.
          </dd>
          <dt>Should we be nice to it, like in Blade Runner?</dt>
          <dd><p>It could have as much claim to consciousness as any similarly complex machine, and the entire network may grow to dwarf the complexity of a human mind, but any internal experiences it might have will not resemble our's in the slightest. We'd have more to talk about with, say, a spider than one of these digital life forms, and they won't be half as cute as polar bears, so the chances of humans empathising with digital life emotionally are slim. Besides, shouldn't we start by learning to be nice to other humans?</dd>
          <dt>Is this like playing God?</dt>
          <dd><p>If you're an atheist, that won't worry you, but if you're religious, you'll be glad somebody decided to play God for the world we live in. Why shouldn't somebody else play that role for a new world in which something else will live? <p>Religious people will find it interesting that this project needs the equivalent of natural disasters to make it work, that being one of the stickiest questions posed by atheists. On the other hand, they'd be dismayed by the idea of a god who expected his creations to surpass his own intelligence and power.</dd>
          <dt></dt>
          <dd></dd>
          <dt></dt>
          <dd></dd>
        </dl>
      </div>
      <div title="What is Intelligence?">
        <dl>
          <dt>Purpose: Help preserve life; meaningless outside of that context</dt>
          <dd><p>Any biological species could have developed a huge brain if it had had a use for one, but most decided against it because brains are very expensive. Ours guzzles 20% of the body's oxygen and hence energy budget, in return for which it moves us to anti-evolutionary behaviours like eschewing reproduction in favour of careers. Freak organs like this can be observed in other species like the giraffe, peacock or fiddler crab, and the explanation usually lies in an arms race within the species or with one they interact with. 
          <p>An efficient species has just enough brains (or any other organ) to stay alive. If we lose sight of this fact, we demand pointless tricks from our supposedly intelligent machines and fail to see how not doing something is sometimes smarter than doing it.
          <p>For instance, AI people like to build pattern recognisers that respond differently to trained images of e.g. houses and trees. However, humans generally ignore both of these everyday objects whilst responding strongly to unfamiliar stimuli. We have learned to handle those everyday stimuli with the minimum cognitive energy expense. This is the very essence of what learning is for. 
          <p>Between the extremes of common, inconsequential stimuli and those we are wholly unprepared for, there are some that call for a trained homeostatic response in order that our situation remains within an envelope where most likely stimuli can be dealt with by such a trained response. The experience of walking, for instance, consists of a rapid stream of stimuli which we are so well trained at responding to that with only a slight expense of cognitive energy we can maintain ourselves within a narrow range of physical positions where only a small repetoire of trained responses is required to maintain the control. 
          <p>The more effective the responses are at keeping us within their expert range of situations, the more they are reinforced by learning and the more solid their evolutionary strategy is (see 'memes' below.) That begs the question: how do we ever stop walking? There are indeed behaviours that never seem to stop, such as drug addictions, but the usual case is that the walking itself is a homeostatic response within a range of higher level situations. For instance, we might be walking to a restaurant in order to keep our hunger within a range we know how to deal with. That walking is to hunger control what leaning right or left is to walking. The higher aspects of life can be modelled in the same way. 
          <dt>Not artificial schizophrenia</dt>
          <dd><p>Lifeforms are not expected to impersonate other species, especially not radically different ones. A software that attempted the Turing Test (a challenge in which a program attempts to pass as a human) would be making this highly unintelligent mistake. Such a bizarre program could potentially be designed but would never evolve freely.</dd>
          <dt>Start with the nematode</dt>
          <dd><p>This highly successful arthropod's control system consists of roughly 300 neurons and 7000 pre-wired synapses which have now been reverse engineered in intricate detail. Nematodes exhibit hunger, satisfaction, fright, exploration, a sense of direction, and short term learning. They provide an answer to the question above about why we stop walking. Higher forms of intelligence should be understood as stepwise developments of this one, the steps having been justified by some identified need.</dd>
          <dt>The computational substrate doesn't matter</dt>
          <dd><p>Given that some machine can learn by trial and error or internal simulation of the same, the behaviours it will adopt are those that succeed in its environment. This is not affected by whether the machine is based on neurons, transistors or any other computational machinery. For this reason, it is of no consequence that this AI project is not based on neuronal computing.</dd>
          <dt>Memes</dt>
          <dd><p>In this theory of intelligence, thoughts, beliefs, habits, words, religions, technologies, etc are observed to gain popularity or be forgotten in accordance with Darwinian dynamics. 
          <p>The idea originated with Herbert Spencer who applied it to sociology around 1857, and was applied to individual cognition by Richard Dawkins in 1976 by pointing out the plurality of (sometimes contradictory) ideas that make up an individual psyche and the energetic attempts on the part of those ideas to reproduce into other peoples' minds even at the expense of the interests of the host human. Neither theory shares the virtue of biological Darwinism that novelties originate in random variations. Another project might attempt to establish random variations in neuronal firing as the origin of intellectual ideas, but that is not the focus here. 
          <p>If we accepted that our psyche consists exclusively of memes acting in their own evolutionary interest, and that our own interest is merely an illusion generated by memes in order to gain control of our actions, then we would have settled on a version of Zen.
          <br/><br/><div class="box">This project sees brains, societies and computers as VMs in which Darwinian evolution of behaviours can take place.</div><br/>
        </dl>
      </div>

      <div title="Comparison of worlds">
        <table width = "100%">
          <tr>
            <th width="20%">Criterion</th> 
            <th width="20%">Biosphere</th> 
            <th width="20%">Brain</th> 
            <th width="20%">Society</th> 
            <th width="20%">Computers</th> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td><b>Inhabitants</b></td> 
            <td>Animals etc</td> 
            <td>Behaviours, ideas</td> 
            <td>Behaviours, culture</td> 
            <td>Programs</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td><b>Space</b></td> 
            <td>Land</td> 
            <td>Stimuli</td> 
            <td>Believers</td> 
            <td>Memory, events</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td><b>Size</b></td> 
            <td>10<sup>9</sup> km<sup>3</sup> of ocean</td> 
            <td>10<sup>11</sup> neurons, 10<sup>15</sup> synapses</td> 
            <td>10<sup>10</sup> people</td> 
            <td>10<sup>10</sup> computers, servers and phones * 10<sup>12</sup> bytes</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td><b>Success</b></td> 
            <td>Population</td> 
            <td>Domination of range of stimuli</td> 
            <td>Popularity</td> 
            <td>Domination of range of market opportunities</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td><b>Dimensionality</b></td> 
            <td>2.5</td> 
            <td>Moderate: Each stimulus situation is similar to a small set of other situations.</td> 
            <td>High: lots of phone numbers</td> 
            <td>V. high: many memory locations effectively equidistant with a given one.</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td><b>Energy</b></td> 
            <td>Food</td> 
            <td>Enthusiasm</td> 
            <td>Upheaval</td> 
            <td>Money (see later)</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td><b>Scarce material</b> (other than space)</td> 
            <td>Amino acids etc</td> 
            <td>Basic ideas</td> 
            <td>Basic ideas</td> 
            <td>Code snippets</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td><b>Persistence</b></td> 
            <td>Physical/chemical inertia</td> 
            <td>Synaptic retention (and evolved techniques)</td> 
            <td>Dogma</td> 
            <td>Memory</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td><b>Malthusian limits</b> (important to cause selection)</td> 
            <td>Space, chemicals, sunlight</td> 
            <td>Practical incompatibility of behaviors</td> 
            <td>Mutual rejection of cultures</td> 
            <td>Memory, internet bandwidth, CPU time upon interesting events, UI, human goodwill</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td><b>Self replication</b></td> 
            <td>DNA</td> 
            <td>Generalisation of a given response to similar stimuli</td> 
            <td>Gossip, teaching</td> 
            <td>memcpy (with added errors)</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td><b>Accidents</b> (important to prevent stasis)</td> 
            <td>Natural disasters, mutations</td> 
            <td>Forgetfulness</td> 
            <td>Misunderstandings</td> 
            <td>Must emulate in VM</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
        </table>
        <div class="box">Evolution is guaranteed to happen in any system that has a imperfect self replicator and limited resources.</div> 
      </div>

    </div>
    <div title="Types of VM">

      <div title="Free (as in freedom) VM">
        <p>This system is not useful but illustrates unsupervised software evolution. Code at github/adrianmay/digilife.
        <ul>
          <li>Boot normal PC into protected mode.</li>
          <li>Single writable memory segment for code & data.</li>
          <li>Fill with large program written at random.</li>
          <li>Interrupt periodically and randomly flip bits.</li>
          <li>Exceptions just jump back to random position.</li>
          <li>Detect life by measuring compressibility.</li>
          <li>Get bored of it. (No utility. Can't understand it. Drinks electricity.)</li>
        </ul>
      </div>

      <div title="Useful VM">
        <p>Definition: one that won't get switched off due to lack of utility in the eyes of the computer owner.  Notice that this definition extends the Darwinian criterion to the VM itself. The goal of this project should now be clear: it's not a lab toy, its a life form adapted to the current world of humans and computers.
        <p>Rather than designing it, let's try to deduce what it must be like. The danger of design is that it might arbitrarily limit the future possibilities to things which the designer expected, rather than allowing for the full range of things which might be discovered by an evolution-based intelligence higher than his own. We should prefer VMs with more general capabilities unless something speaks strongly in favour of a restriction.
        <p>Why would the computer owner keep a software on his computer although it consumes memory and electricity? There can only be two reasons:
        <ol>
          <li>It serves him.</li>
          <li>It serves somebody who pays him for those services.</li>
        </ol>
        <p>That somebody must have money, but must not necessarily be human.
        <p>In case 1, we can seperate the owner's role as a consumer from his role as a hardware owner, leaving two roles:
        <ol>
          <li>Hardware owners spend their own money maintaining machines on which digital life runs, whilst selling the services rendered by the life to...</li>
          <li>... consumers who pay the hardware owners for the utility rendered by the life.</li>
        </ol>
        <p>It's now pretty clear what kind of life-hosting VM will be selected by hardware owners. It should make the expensive and limited processing resources available to the most lucrative tenant life forms whilst culling any species whose resource consumption exceeds its earnings. To maintain generality (i.e. avoid unforced design decisions) it should not rule out team work between tenants. But how? 
        <div class="box">It should track a bank account for each individual tenant program, credit external revenue to a tenant involved with the rendering of the revenue-earning service and auction processing resources (memory, proctime, internet bandwidth, GUI, early notifications) to the highest bidder.</div> 
        <p>An accurate VM will attempt to get paid for all of the resources used by the whole installed system. This should include the VM's own activities, especially when requested by a tenant.
        <p>It's healthy for the hardware owner and his agent, the VM, to try to extract the highest possible revenue from the whole set of hardware used. This is because such a policy makes the ecosystem approach Malthusian equilibrium at all times. If resources were made available for free or at an artificially reduced rate, they'd suffer over-demand and some other basis for allocation would take over, such as first-come-first-served. This other basis would be less effective at guiding evolution in the direction of value to humans.
        <p>If the hardware owner cannot extract enough money from the ecosystem to pay the costs he incurrs for electricity, labour, space, depreciation, etc then he'll either put it to sleep temporarily or dispose of it.  
      </div>

      <div title="Value Chains">
        <p>We must now decide between these options:
        <ol>
          <li>Each tenant must earn money directly from a human.</li>
          <li>Tenants may exchange money between themselves</li>
        </ol>
        <p>It would be ridiculous to rule out tenants earning from humans, therefore case 1 above is strictly a subset of case 2. No reason to restrict the VM to case 1 springs to mind, rather, the implications of generalising to case 2 are interesting and attractive.
        <p>In case 1 each individual tenant would have to be intelligent enough to perform some saleable service all by itself. This would lead to a society of very large and delicate programs. Most mutations would break something rather than enhancing it.
        <p>In case 2 though, it is possible for value chains of many tenants to develop which would perform complex computations in a distributed fashion. This brings challenges of its own, but if the society could evolve self-organising and self-repairing techniques, then high complexity would no longer be an impediment to further evolution.
        <p>We therefore choose case 2 and notice that humans and tenants have similar rights to own and use money with this respect to this VM. Even the hardware owner could in principle be a program.
        <p>The pressure is on each tenant to deliver some needed computational service at a good price whilst facing competition. That would involve obtaining required raw information cheaply and processing it efficiently. The system is entirely analogous to capitalist economics. Some will dislike the brutally capitalist nature of this system, but I'd wager that any proposed alternative would evolve internal mechanisms that brought the rules back to the same deal. It may be palatable to start with a toy currency but an exchange rate into dollars would soon develop anyway.
        <p>A society that successfully supports value chains can be expected to have other characteristics:
        <ul>
          <li>Members should be able to defend their money and saleable assets. There may be some members with the power to confiscate assets from others, but in that case the powerful ones must refrain from plundering all of the vulnerable ones. For any trade to occur, there must be some pairs of members who cannot plunder one another. </li>
          <li>Information is the main saleable asset in this system, so some tenants must be able to hide information from some other tenants.</li>
          <li>Members must be able to communicate. Whichever means of communication is used for transfering saleable information must be unobservable by some non-paying peers. </li>
          <li>Communication may occur because either the sender or the receiver wants it to. </li>
        </ul>
        <div class='box'>Communication and payments between tenants must be supported and their privacy respected.</div>
      </div>
    </div>

    <div title="VM Requirements">
      <p>Whilst hypothesising about possible life forms and their strategies in this section, it will become apparent that to stay alive at all, a program must be fairly complex, master a large range of skills and adhere to some cultural norms that have not yet evolved. In the light of the complexity of bacteria etc, it should not seem surprising that the minimum self-sufficient software is a rather complicated machine. 
      <p>This could seem like a chicken and egg problem, but the solution to this lies in a nursery school stage to be described later. Hand coding is another possible solution which the author, but perhaps not everybody else, will try to minimise.
      <p>Fundamentally, what's been proposed above is a trading system for money, processing resources and secrets. 
      <p>As the hardware owner's agent, the VM wields omnipotent power over the other members of the society but does not use that power in a way that adversely affects the efficiency of the system. Until we discover an exception, we'll assume that the VM behaves in a similar way to other members and is merely rich amongst peers. For instance, the VM owns processing time when it first appears on the horizon of the foreseeable future, but having sold the right to use that time to some tenant, it will respect that right. An important reason for keeping protocols harmonised whether or not the VM is involved, is that we invite tenants to evolve improvements over the inefficiencies of the hand-coded VM. (Indeed, an early and easy challenge for evolution is the division and subletting of large, VM-provided resource blocks.)
      <p>These statements about the VM are justified by Darwinian logic: a different style of VM would make less money for the hardware owner, and hence lose the battle of environmental selection, the environment chiefly comprising the hardware owner in this case.
      <div title='Money'>
        <p>Conserved quantity, transferable, essential.
        <p>Debit correct tenant for resource costs.
        <p>Credit external sales to the correct tenant. External payer must provide hint to VM about which tenant to credit. Tenant must arrange that.
        <p>VM's profit may be creamed off or redistributed to tenants according to some HW-owner-defined benefits system.
      </div>
      <div title='Bookings'>
        <p>Tenants book windows of processor time in advance, specifying code to be run during the window. If we suppose that the selection of the lucky tenant does not begin until the window, then we might as well redefine the "window" as starting from when the lucky tenant's code can start. In that case, the distinction would merely be how far ahead of time the selection process takes place. We stated earlier and still assume that the selection process must be some kind of auction, or at least have the virtue of handing control to whichever tenant is likely to generate the most value from the resource time, in spite of the VM only being capable of judgeing tenants using hand-written code.
        <p>If the auctioning of the time does not start until the window is underway, then the VM will have less time to collect bids and therefore sell more cheaply. No VM will opt for that because a VM's very purpose in life is to maximise earnings from the auctioning of resources. 
        <p>There is no question of whether or not some code reached completion during the CPU time block. Control simply remains with the owner of the time window until the transition to the next booking occurs. Window owners may make efficient or wasteful use of their time and it is their problem to cope with the loss of control at the end of the window. A competent tenant must know the duration of the window because it decided to buy it.
        <p>The VM wants to minimise the resource consumption incurred by the bidding process and make a deal for each and every window. An efficient procedure is for tenants to place bids in which their constraints on an acceptable deal are unambiguously stated. These constraints include the range of acceptable times for a window (e.g. before the tenant dies) and prices. The VM might charge the highest bid, or slightly more than the second best bid. The VM might publish price averages for the tenants to consult. Another useful feature would be for a bidder to place a set of alternative bids, exactly one of which he wants fulfilled. 
        <p>Bids spend some time being collected and compared by the VM. Low paying bids are likely to wait longer before being granted a window. A pending bid occupies memory and thus incurrs costs per unit time, so a very low paying bid might wait so long in the pending area that it bankrupts itself before being granted what it asked for. That is not unusually tragic as there are many other dangers facing tenants in this system, but it raises the question of how space in the bidding area is granted. If it must be bid for in the usual way, then we have a circular problem. A simple and workable alternative is to design the bidding area to require a minimum of space, and then to suffer some approximations in the way that space is payed for, namely, that the rate and time-to-live for a bid are fixed, so that a fixed fee can be levied when a bid is placed. This topic lends weight to the suggestion that the resource blocks directly sold by the VM are fairly large and will probably be divided and sublet by the winning bidder.
        <p>Similar comments apply to internet and memory time. Language features for reading and writing to blocks of all kinds will be discussed later.
        <p>Often the VM itself is occupying time which cannot be blamed on any specific tenant. The VM should attempt to track these costs in detail, but inordinate amounts of computing power cannot be spent on accounting, so some inaccuracy is inevitable. The main thing is that some account should exist for VM costs that cannot be blamed on any particular tenant, to be funded from VM profits.
        <p>There should be some stochastic factor affecting which tenants win processing resources. If the highest bidder always wins, he will surely remain the highest bidder no matter how worthy the others might have become given the chance. How influential the stochastic factor is is a matter of VM tuning to be experimented with.
        <p>Belongs elsewhere ==> Often, tenants are bidding on the same memory block they have occupied since birth, in which case the system can avoid a memcpy by awarding the same physical block. In general, tenants can occupy several blocks besides the one containing the code that's bidding, so if a tenant has a preference for a particular physical block then it will have to name that block in its bid. When the bid is fulfilled, the tenant needs to be able to ascertain whether the same or a different block was obtained in order to know whether or not to perform the memcpy. If any block can be named including those belonging to neighbours, then a form of warfare might result where tenants bid highly for blocks occupied by peers whose existence they consider detrimental to themselves. This could be prevented if the VM required the password for a block to accompany any renewal bid, but some VMs might find it amusing to allow this form of warfare.
        <p>Usually, the VM will honour any bookings it agreed to, but its first duty is to earn money for the hardware owner and there may be times when a lot of money is offered to break the rules. A rational VM would only reject such an offer if the damage done to future earnings by the breach of contract outweighed the payment for doing so.
        <div class='box'>Tenants bid for resource time windows in advance. The VM tends to give priority to high bidders.</div>
      </div>

      <div title='Authentication'>
        <p>In order to stay alive, a tenant has to make sure that the leases on the memory blocks where it lives are renewed before they expire. Usually, the tenant will do that for itself with its own money, but anybody's money is as good as anyone else's. Either way, a tenant with an interest in maintaining the existence of a block must have access to a bank account that usually contains sufficient money to cover the memory rental, and access to that bank account must be denied the majority of other tenants who care less about the one in question. Besides this exclusive access to the bank account supporting the block, we also require that write access to the block is similarly limited to a priviledged few. 
        <p>How are these rights granted and tracked? The choice is between (1) a system where the VM tracks access rights to resources by individual tenants, and (2) a system that grants rights to those who know a secret. The latter is more flexible, for instance, it allows the same right over the same resource to be granted to a plurality of tenants. The secret-based system reduces to the identity-based system in the case that the secret is disclosed to exactly one tenant at the moment when the right springs into existence, and where that tenant does not divulge it to any other. We've already established that tenants must be capable of keeping secrets from at least some peers in order for any value chain to develop, and that requirement is slightly extended here to the ability to prove knowledge of a secret without divulging it to any party who could use it against the owner. Assuming that can be done, we gain generality and lose none by choosing option 2. 
        <p>Public key encryption is the most general solution to this but costs a lot of processor time. There are cases where simpler techniques suffice. For instance, when the VM sells a resource time window to a tenant, it can provide a name and password for the resource over a secure channel arranged by the VM. (Tenants don't have much choice but to trust the VM.) A similarly secure channel can be used when the tenant wants to do something with its resource. A simple (but imperfect) way for tenants to trade such resources would be for the seller to disclose the password to the buyer over the secure VM channel and for the buyer to subsequently use a VM API to change it. 
        <p>However, when authentication is required directly between tenants with no VM involvement, a public key system is probably necessary. An example of this could be to support 'brands' with reputations for honest behaviour. A tenant could prove itself to be related to the well behaved family by passing a PK authentication challenge without enabling the challenger to pass the same test in the future. The private key would be handed down through generations of a single family. Digital signatures would do the same thing.

        <div class='box'>Resource time windows are protected by passwords divulged to the successful bidder.</div>
      </div>

      <div title='Permissions'>
        <p>For memory blocks, we can see at least four types of permissions, each to be protected by passwords. They are: read, write, execute and change passwords. The execute permission means that a peer with control over a CPU window can nominate this block's code to be executed by the VM during that window. It can usually be granted to everybody by a well developed life form; its code is already secure against malicious invocations and free CPU time is a valuable gift, but most peers do not have the right to read the code as that would involve all its secrets being disclosed. Whatever executes the code obviously needs to read it. By default that is the VM, but if we want to allow languages to evolve then this cannot be a VM monopoly, so there may be cases where tenants grant other tenants read access to their code. That would not be execute access because the code being executed is the interpreter of the evolved language, not the code in that language. 
        <p>Some blocks are not private code and secrets but information which the tenant wishes to pass to a specific peer or advertise to the world in general. If these blocks should persist for any length of time, then it's important to deny most of the readers write access. 
        <p>The password changing or 'admin' permission allows any of the four rights to be withdrawn from its current audience and retained only by the changer of the password. That this must be seperate from the write permission is not clinchingly clear, and lies at the discretion of the VM programmer. 
        <p>TBC: which permissions imply one another.
        <p>Next we consider an internet time block from a sender's perspective. The data to be sent during the time window should have been specified before the window starts and must reside in some memory block which already has the above permissions associated with it. What the intention to transmit over the internet adds is the permission to specify which block will be sent when the time comes. This is essentially a write permission over the internet time block. The admin right applies to the degree that internet blocks can be traded directly among tenants, but the read and execute permissions are irrelevant. Internet from a receiver's perspective will be dealt with later.
        <p>Processor time blocks similarly have a write permission for specifying what code to execute during the window and an admin permission for trade. The execute permission does not apply because a mere time window does not contain executable code.
        <p>For internet or CPU windows, the read permission would have meant that other tenants could see which memory block is scheduled into the window. It's hard to think of a reason why this would be useful, especially if the reader did not have read permission over the scheduled memory block.
        <p>Finally we can consider permissions over bank accounts. We distinguish permission to make payments out of an account, deposits into it, and to inspect its balance. By analogy with the likelihood of these permissions over memory blocks being granted to a wider audience, we can (somewhat arbitrarily) associate these with the write, execute and read permissions respectively.
        <p>There is a way that we can avoid requiring the VM to busy itself with all these permissions. We set execute permission to true and read and write permission to false for all memory blocks. Then, a block may or may not be programmed to divulge or overwrite its contents when asked to. If so, it might ask for a password first. With such a system, the VM need only understand the admin password and it would be evolution's job to invent the others. The CPU and internet blocks only needed one right anyway. As for bank accounts, we can allow anybody to pay into an account and only the admin owner to pay out of it. It's an ideological question whether neighbours should be able to read each others' bank balances or not, but that right would probably be granted to everybody or nobody but the owner, without any more fine grained control.

        <div class='box'>Resources can be traded amongst tenants by divulging passwords. <br/>Read/write access to a memory block is the responsibility of the program in the block.</div>
      </div>

      <div title="Messaging">
        <p>In human society, communication is about making a piece of data available to another person's code. The data may contain code and be executed as such, and the provider of the data has no control over what the receiver does with it and how long he remembers it for. Data can go out of date or be forced out of date by e.g. changing a password, but the cat cannot be talked back into the bag.
        <p>Suppose, for some reason, one tenant wants to present a piece of data to another with the expectation that the latter does something about it. We'll assume that the motivation for this to take place lies with the sender. The sender may book some CPU time and nominate the receiver as the code to be run during that window (subject to the sender's execute permission over the receiver) but the data also needs to be transmitted somehow. We already discussed mechanisms for renting a block of memory, writing something into it and making it readable for a peer, but still we need to draw the receiver's attention to the block. It's also arguable (but not conclusive) that some information about the sender should be made available to the receiver obligatorily.
        <p>From this argument we know that in a messaging-capable VM, the owner of a CPU window may specify not only the code to be run but also some environment of supplementary data to be made available to that code. The VM might supplement the environment with various other data either about or independent of the CPU window owner, e.g. global economic barometers like resource prices, queue lengths, time to live of various windows, etc.
        <p>The phrase "sending a message" thus means obtaining a future block of CPU time and configuring it to run a peer's code (the 'receiver' of the message) with some readable memory blocks (the message 'body'') listed in the environment of that CPU window.

        <div class='box'>Tenants can invoke one another, contributing data to the environment of the invocation.</div>
      </div>

      <div title="Payments">
        <!--
        <p>By definition, money is a relationship between a tenant and the VM. It's the hardware owner's estimation of whether or not he wants that tenant on his computer, as calculated by his agent, the VM. It originates in payments from human clients to the hardware owner in return for services, and is depleted when the owner pays electricity bills etc. Payments between different hardware owners and human consumers need to be secured in some traditional way, and the hardware owner has to power to credit as much or as little of the money in his balance to the digital life. It would be logical for him to attribute all this money to digital life and then charge it for his services in looking after it, because that way the VM's balance would tell him whether this enterprise was worth his while or not.
        <p>However, tenants can make similar judgements about one another. One tenant might pay for a neighbour's housing or transfer money to it to use as it sees fit if it feels that the existence of the neighbour tends to its own survival. That would especially apply if it felt that the degree to which the neighbour will tend to its survival in the future is dependent on whether or not a payment is made now. The VM certainly understands that if no client payments are attributed to the contributing tenants then the whole system would fail.
        -->
        <p>A payment would take place if there were an account containing some money whose name and relevant passwords were sent from one tenant to another, the latter subsequently changing the passwords. Without support for splitting and joining accounts or making transfers from one to another, each account would effectively be a coin and these would be required in various denominations and large numbers. It would work, but not be very efficient.
        <p>If accounts could be split and joined then transfers could be made between existing accounts: an arbitrary amount of money would be split off the source account into a transfer account whose passwords would be communicated to a receiver who may then merge it into any existing account.
        <p>We could also propose a simpler transfer system that didn't involve an intermediate account, but we still need a way to create new bank accounts for reproduction and dissolve those of dead tenants. The splitting and joining approach is probably the simplest mechanism that meets all the requirements. It also extends nicely to the secure trading platform described next, but it's not the only conceivable approach. 
      </div>

      <div title="Secure trading">
        <p>It's not obligatory for the VM to provide a safe trading API; we could also set up a primitive and brutal world and let evolution develop systems for making it more efficient. However, the VM is likely to protect its own interests, and we are trying not to give it special priviledges.
        <p>For instance, when the VM books a time block to a tenant it is likely to insist on payment up front. We can extend that expectation to any other seller of resource time. If we consider a trade of money for time to be a symmetrical one in principle, then the VM's insistence on checking the buyer's intention and ability to pay by requiring immediate payment can be generalised to anybody's desire to check that the valuables being offered for exchange actually exist and will be delivered. If we avoided any of those generalisations, then we'd either be giving the VM a monopoly over certain abilities or we'd be introducing an asymmetry between money and other resources, both of which are unattractive at this stage.
        <p>The simplest system that protects both parties is as follows: (1) one trader drops his goods in a box provided by the VM together with a description of acceptable exchange goods, (2) the VM inspects and advertises to the world what the deposited goods are, (3) another trader drops some exchange goods in the box, (4) the VM inspects these goods and if they fit the first partner's description hands the exchangeable goods over to each receiver.
        <p>How would that work in the case of digital life? Goods are easy for the VM to inspect and verify. It tracks all the resource blocks, accounts and passwords. In PK protocols it can attempt a challenge using the private key being sold. It is also easy to unambiguously describe what goods are acceptable for exchange. It could be a simple quantity of money or a resource window within certain constraints. This would be a VM-provided service but evolving software could compete with it and hope to be trusted. 
        <div class='box'>The provision of a secure trading platform minimises the difference between VM and tenant rights.</div>
      </div>

      <div title='Sub-letting'>
        <p>The time taken for a computer program to complete is not in general predictable, especially not if that program just came into existence by random mutation, so we can expect tenants to regularly end up with spare time booked. It's not in the interests of the system for this time to be wasted. It could be of value to some neighbouring tenant but if it becomes available at very short notice then the act of finding a buyer will take up a portion of the spare time. The more the seller tries to minimise that time wastage, the fewer bidders there will be and the lower the price the seller can obtain. It's usually better to arrange bookings as early as possible. 
        <p>Another scenario where sub-letting could matter is where a tenant has bought a large block of time hoping to profit by distributing it to others, as will become apparent in the next section.
        <p>Given that a member (VM or tenant) has some resource time booked of which it wants to sell a portion to somebody else, there are numerous ways in which the buyer can use the time. 

        <p>Method A is that the seller retains ownership of the resource but follows the buyer's instructions about what to do with it, for instance, it may read the the buyer's code and execute it piecewise or just jump to it if the rest of the window is being sold. For memory blocks, the seller would be trusted with knowledge of what the buyer wants to store, but the same trust relationship exists between any tenant and the VM. This is already possible in any VM supporting communication and payment. 

        <p>Method B is that the seller tells the buyer the passwords to the resource. This assumes that the rest of the window is being sold in one go.

        <p>Both of the above are seen to be inadequate when one considers that a negotiation had to take place before the handover. The owner's window was already underway and several potential buyers may have been propositioned before a deal was made. That all had to happen before the owner's window expired, so the owner must have been running other tenants' code without giving away the whole window. Method B was certainly not used at that time, and if it was method A, then piecewise execution must have been performed so as to retain control. That involves many innefficiencies and complications, if it's possible at all.

        <p>What's required is a means whereby the owner of the current window can relinquish control for a fraction of the future of that window and reliably regain control afterwards. Method C is that the owner should approach the VM with a request to subdivide the window into smaller windows each with a different password. This is possible but messy. 
        <p>A cleaner way is to simply offer whatever mechanism the VM is already using to police deadlines to tenants in general. The VM sets timer interrupts for the expiration of CPU bookings and simply hands control to whoever booked the next window. For memory bookings, the passwords to the block are changed and the new ones handed to the next occupier in a message. Method D is that the current owner of some resource can similarly set a timer before jumping to some peer's code. Assuming some communication should take place between owner and buyer, it will be necessary for the owner to set up an environment for the sub-invocation. For memory sub-letting the passwords need to be changed by the VM at the beginning and end of the sub-letting period. In both cases the process is the same one used by the VM to let resources for controlled periods. If a tenant is entitled to do this then that entitlement lies in his current ownership of the resource, which we test with passwords.  
        <p>This mechanism would make the earlier proposal that tenants can book CPU time in which some other block should run redundant. They could just sub-let instead.
        <p>Note that memory blocks can be split by space as well as time. 
        <div class='box'>Tenants can synchronously invoke one another for a controlled portion of their CPU time windows.</div>
      </div>

      <div title="The Sub-VM">
        <p>Describe a tenant that completely virtualises the VM, including the programming language for tenants, and why it would do well.
      </div>

      <div title="Callbacks">
        <p>We established early on that resource time must be booked in advance. Not all times are equal though. After an interesting event, like the arrival of an invitation to place some advert on a web page for instance, demand and prices for resources will be much higher than usual. The VM would like to cash in on this effect.
        <p>To the extent that the types of these interesting events can be evaluated in advance, one can treat their immediate aftermath as a special category of time to be auctioned seperately. For instance, time when an incoming network packet is waiting for examination could be an expensive category of time. There's a danger of double booking with this approach though, because apparently uneventful time is being sold in advance but events arrive unpredictably.
        <p>Furthermore, that aforementioned extent is not very large. Some network packets are just common worms while others are from rich humans. The most interesting events will be beyond the VM's ken and detected by yet-to-evolve software. We'd like to encourage that evolution. The VM may cash in on knowlege of secrets it understands, but the same opportunity should be available to the tenants, whose intelligence is expected to surpass that of the VM if and only if that intelligence enhances the tenant's survival chances. Under what set of rules would this type of evolution be practical?
        <p>Sub-letting and selling on of CPU time has already been discussed. This is one way to profit from detecting interesting events. When the event arrives, the detector buys up lots of processor time and then distributes it at a high rate among interested clients, who, we may presume, are all clamouring to be informed before the others. The detector will have some kind of client list in place before the event occurs, otherwise the prime time would have to be wasted finding clients when that could have been arranged in advance and recorded on the client list. More realistically, the detector and clients would have evolved in symbiosis with one other and effectively comprise organs of the same distributed creature. Bearing in mind that the detector's client list will incurr memory costs during the uninteresting periods, that those costs will almost certainly be met by the detector in the first instance and that the detector must make profits in proportion to the number of clients it has, we see that the costs for remembering clients are likely to be passed on to the clients at a marked up rate. This offers another revenue stream for the detector. 
        <p>Event detectors might subcontract mailing to a family...
        <div class='box'>It's good to be on a mailing list, and expensive to be at the front.</div>
      </div>

      <div title="Names">
        <p>To make a new block, a new name needs to be allocated, unique at some scope or other, and the parent may or may not influence the choice of name. It is always possible for a parentally chosen name to be rejected due to non-uniqueness, so the parent must be informed of the success or otherwise. If the name is allocated by the container then the parent will be told of the choice. The general description of this state of affairs is that the container will influence the name, the parent might, and the parent will be informed of the final outcome by the container. We appear not to lose generality by denying the parent any influence, so until some counterargument arises, we'll assume that the container allocates names. In this context "container" probably means VM, but we'll see later that it might mean a kind of super-tenant.
        <p>Problems with naming schemes ... PK reputation instead
        
        <div class='box'>Names and passwords are allocated by the VM and follow no scheme other than uniqueness to the VM.</div>
      </div>

      <div title="Memory">
        <p>Scope, tree organisation
        <p>Must distinguish rebooking a currently owned block from requesting a new one.
      </div>

      <div title=" Reproduction">
        <p>Hook up and finance children, etc.
        <p>Not-so-random mutation.
      </div>

      <div title="Accidents">
        <p>We need them to avoid deadlock
        <p>How the society copes with death and change.
      </div>

      <div title="Tax and welfare">
        <p>Just economics.
      </div>

      <div title="Cardinality">
        How many Xs per Y, X and Y being tenants, blocks, accounts, names
      </div>

      <div title="The Language">
        <p>What language are these life forms written in? 
        <p>We're rather spoilt for choice. Any language would do, and the usual virtues of coding ease, maintainability and robustness do not apply because no human will be expected to write in it.
        <p>However, we must abandon the concept of a syntax error and similar value judgements. Code will often originate at random and <i>will do something</i> when run. If that something is to crash, that may be the desired behaviour, but there's no particular reason for a great proportion of possible programs to behave in that same way. Rather, the behaviours of programs should be distributed more or less  evenly over the range of writable programs. This is one desideratum for the language to be designed.
        <p>Another is that slight variations of the code should result in slight variations of the behaviour. Random variation of code is our most basic means of creating variants and will dominate until something better evolves.
        <p>Yet another is that it should allow the tenant to perform the essential chores of life. These include:
        <ul>
          <li>Bidding for resources</li>
          <li>Remembering names and passwords</li>
          <li>Reading and writing blocks</li>
          <li>Querying one's bank balance</li>
          <li>Quoting one's own code</li>
          <li>Sending messages (i.e. invoking peers in an environment) and payments</li>
          <li>Registering on mailing lists</li>
          <li>Looking for services</li>
          <li>Creating new tenants</li>
          <li>Performing various computations, especially regexes</li>
          <li>Efficient mutation</li>
          <li>Turing completeness</li>
          <li>Etc</li>
        </ul>
        <p>Different VMs may interpret radically different languages but nevertheless evolve similar behaviours when exposed to the same environment and opportunities. The efficiency of computation (and therefore the edge in the evolutionary race) depends strongly on the design of the underlying language and it is primarily on this basis that VMs will compete wth one another. Forth-like langages are pretty fast, and there may even be languages that usually exist as a parsed tree and only linearise themelves for crossing machine boundaries. 
        <p>The code will be run in an environment of global data, invoker-provided data and the tenant's own state. The result of the execution includes the possible alteration of any resources the tenant has permission for including the configuration of future CPU windows. The basic life chores might be accomplished by outgoing messages or by some other primitives of the language.
        <p>Many applications will be about text processing so regexes could have a role to play. Regex pattern matching (i.e. excluding substitution syntax) could be augmented like this:
        <ul>
        <li>Characters that evaluate to environment variables</li>
        <li>Submatches captured with round brackets could be routed to named destinations rather than just numbered registers</li>
        <li>Those destinations could be: 
        <ul>
        <li>memory blocks</li>
        <li>message receivers</li>
        <li>processing pipelines in this same regex-based language</li>
        </ul>
        </li>
        </ul>
        <p>This regex approach is just one of many ways of building a VM.

        <div class='box'>A good language may be indecipherable but may not issue syntax errors.<br/>Random variation should often lead to something useful.</div>
      </div>

      <div title="Training">
        <p>The language will not be implemented in one fell swoop because primitive tenants will not be capable of using much of it anyway. Rather, a nursery training phase is planned where we progress from one lesson to the next by introducing a new language feature and programming the VM to give out rewards to tenants that discover it. A few interesting phases in this training process are described below: 


      <div title="Self preservation">
        <p>All tenants must at all times have a future CPU booking in place, and they must continuously maintain a booking on the memory where their code is stored. We could make this very easy by introducing syntax to the language that does so with sensible defaults, those defaults being calculated by the VM based on economic conditions. For instance, any character from A to I could mean book a future CPU window soon, and the charaters from J to R could mean book this same memory block from its moment of expiry for some default duration thereafter. Then the program "AJ" would be a viable tenant (until it gets destroyed by an accident or runs out of money) and a large proportion of randomly written programs would be of this viable type. 
        <p>At this stage, money is distributed equally and unconditionally to all tenants. The total rate of money injection equals the total money extracted in resource fees.
      </div>
      <div title="Procreation ">
        <p>We can similarly interpret the letters from S to Z as reproduction instructions. The default style of reproduction is to book a new memory block, inject ones own code into it (subject to a mandatory risk of mutation) and book a CPU window for it.
      </div>
      <div title="Tuning">
        <p>The program "AJS" has severe shortcomings but it can't be improved upon in the language described so far. Having evolved a culture of programs like "AJS", "ZRI", etc, we then change the interpreter such that A to I are not identical but vary in some detail, such as the bid. E could mean offer the default bid while A means bid very low, I very high with the other letters specifying intermediate values. 
        <p>One of those shortcomings is the tendency to reproduce at every instantiation. Reproduction is an expensive business and if a poor tenant attempts it the result will be two bankrupt tenants. We could introduce the syntax of preceeding an instruction by a digit 0-9 to mean "only if I'm rich", the choice of digit indicating how rich on an exponential scale relative to some default.
        <p>Other adjustments include the duration of the window requested and when it should start. The default behaviour can be deliberately given room for improvement, for instance, the CPU window could arrive immediately before the memory block expires, forcing the tenants to bid high in panic. A tenant who discovers the syntax for adjusting when CPU time should occur can save money by bidding earlier and being reinvoked just before the deadline to check the new time-to-live. That implies that times-to-live can be evaluated in the language. A possible syntax is E//! where ! evaluates to the time to live of the block housing the code and // indicates an inverse square proportionality (whereas * would have meant a linear direct proportionality.) H-!B could mean linear interpolation with ! understood to vary over some sane range.
      </div>
      <div title="Heuristic mutation">
        <p>The VM does not provide a way to populate a memory block with perfect accuracy. All such writes are subject to some mutation. The difference between S and Z could be the degree of mutation the tenant desires. Given that the VM knows about the syntax of the language and can detect that some blocks are being interpreted as code, this mutation does not have to be entirely random, for instance, replacing / with // is a fairly gentle mutation, as is swapping H for I, but swapping I for J is a severe change. Nothing speaks against the mutation algorithm using this knowledge to reduce the proportion of dead mutants, as long as all mutations are possible, however rare.
        <p>As we add features to the language, we'll try to do so in a way that doesn't break old code, but when breaking changes are necessary, the old tenants can be translated.
      </div>

      <div title="Registers">
        <p>Suppose we have a syntax "#" for requesting new memory blocks with decorations to adjust the defaults. The award will probably occur after this CPU window has finished and result in a name and password for the new block, both of which the tenant needs to know next time it runs. #a can mean that in future runs of this tenant the VM should arrange an environment where @a refers to the name of the requested block and %a evaluates to its password. The tenant doesn't need to evaluate the password explicitly for normal uses because the VM can look in the environment it set up, but sometimes a tenant wants to give a password away. # is rather useless without naming a register for the result, so we can make this letter a mandatory part of #'s syntax and enjoy 255 registers. (The apparent implication that ASCII is in use is purely for simplicity.) Names and passwords are both chosen by the VM and might be very long. 
        <p>Registers are what the environment comprises, they can be hierarchial and we can design a syntax for drilling into and modifying it. The current code can be evaluated as a register and drilled into with a parsing syntax.
      </div>
      <div title="Cooperation">
        <p>At some point, tenants must learn the virtue of giving CPU time to peers. One reason they might do so is that the foreign block could have been written by the current one to contain a subroutine of the same program, but that would emerge at a later stage of evolution. Very little evolution is likely to take place until messaging is habitual, so we need to motivate that mutation early. 
        <p>When the system aspires to perform services for external clients, enquiries will arrive at the VM and be made available to interested tenants. Messaging will be used by tenants to express interest in these events, by the VM to distribute them and by the tenants to return their answers. To begin with, we'll simulate this with very simple tasks. 
        <p>Assume the VM opted for the sub-letting rather than the cross-booking mechanism for messaging. We introduce a syntax for synchronousy calling another block with a time limit and an environment. These can default to a proportion of the remaining booking and the entire current block. At first, there is no way to name the foreign block because no blocks know each other's names. So the name must default to a randomly selected peer. That peer can register the name of the invoker during such a "hello, stranger" call and use that name to override the random default in future calls.
        <p>We'll hard code a lot of artificial tenants which map onto VM services. These will cover a large swathe of the tenants' namespace. If a natural tenant invokes one of these it will receive a financial reward and a message betraying the name of the artificial tenant. The natural tenant can note this name and repeatedly message it to collect the reward. This exercise represent registering interest in a primitive form. The total budget for these rewards will be fixed so that the reward for one tenant will be inversely proportional to the number of tenants that have learned the trick.
        <p>It will then be possible to wind down the number of such rewards available, make the tenants reguarly re-register their interest and give priority to those who send money to the registration address.
        <p>At the next stage, tenants will be able to cash in a further reward by performing some simple text manipulation. Registered tenants will receive puzzles together with a return address for the answer. We them embark on a long series of lessons about using regexes etc.
        <p>So far we still didn't bring the tenants into cooperation with one another, but if we have a population where each member masters some text manipulation tricks but not all, and we then introduce lessons which can be solved by a combination of those techniques, then it may be plausible that a distributed solution develops. That would certainly be the case if a kind of middle-man tenant had already developed which could bid highly for puzzles by knowing a repetoire of peers who could solve them. The middle man would tell the delegate to return the answer to himself and take a cut of the reward. Intermediate stages could be required to lead towards the evolution of the middle man.
        <p>What syntax will be needed for this? 
        <ul>
          <li>the calling syntax with an optional callee register, timeout and environment</li>
          <li>the environment drilling and modification syntax </li>
          <li>the regex syntax for reading from the environment and placing answers back into it</li>
          <li>payment and becoming aware of incoming payments</li>
          <li>conditionals</li>
        </ul>

      </div>
      <div title="Graduating">
        <p>At this point the VM is ready to approach real world problems like text completion, media recommendations and intenet advertising. Addressing problems like that is about setting up a rewards regime where tenants are motivated to address the problem at hand. For instance, in a text completion application, tenants would have to risk bidding for a slot on the screen to advertise the completion they offer, and if the user takes the offer a reward would be granted in proportion to the number of keystrokes saved. If music or films are being recommended for sale, then the commission available to an ecosystem that beats any hard coded algorithm would buy an awful lot of computers for that society to run on.
        <p>This policy of guiding the society along a preconceived route to self sufficiency offends against the principle of avoiding design. Setting up a regime in which we can predict what types of program can survive is almost tantamout to writing them by hand. However, at some level of complexity we can expect behaviours to evolve which are not directly related to providing services but which can occur because of the size and richness of the society. These will take place between tenants without any obvious external evidence and will enhance the range of algorithms available to the system. This will eventually result in a full reorganisation of the behaviours that were trained in during the nursery phase. At some point, most of what was taught during training will become extinct and the society will be truly self-invented. 

        <div class='box'>Nursery training is required to build a culture that can survive, reproduce, communicate and perform computation, but the nursery exercises will become redundant in the long term.</div>
      </div>


        <!--
        <p>Whilst trying to avoid 'designing' our desires or expectations into an ecosystem that should evolve freely into a pre-existing world, the system is going to need a few nursery lessons. These might follow a schedule something like this:
        <dl>
          <dt>Exist:</dt>
          <dd>Money for nothing<br/>Book a CPU window for just before your memory block expires</dd>
          <dt>Reproduce:</dt>
          <dd>Single clone-with-mutations instruction</dd>
          <dt>...unless you're poor:</dt>
          <dd>Language primitives for balance enquiry, comparison and dice</dd>
          <dt>Talk</dt>
          <dd>Get paid for emitting any message.</dd>
          <dt>Listen</dt>
          <dd>Get paid more for talking to system animals named in messages to you</dd>
          <dt>Invest</dt>
          <dd>Put more money in messages to named peers to get better interest</dd>
          <dt>Cheat</dt>
          <dd>Name yourself to others and fool them into paying you.</dd>
          <dt>Defend</dt>
          <dd>Try investments and remember results. As fools go extinct, so do cheats.</dd>
          <dt>Reward</dt>
          <dd>Get higher interest for larger deposits by pooling fools' contributions, reward fools to keep them alive.</dd>
          <dt>Think</dt>
          <dd>System animals require text processing, (e.g convert-to-upper) for best reward. Breed a large set of transformations.</dd>
          <dt>Etc</dt>
          <dd>Several more stages developing communal processing and encouraging value chains.</dd>
          <dt>Word-completion demo</dt>
          <dd>Simulated SMS scenario where tenants place adverts on screen with their completions. Ad costs money but selection is rewarded in proportion to number of keystrokes saved.</dd>
          <dt>Internet advert placement</dt>
          <dd>This is a very lucrative and directly applicable challenge for such a system.</dd>
        </dl>
        -->

      </div>
      <div title="Internet">
        <p>Don't know going rates on receiving machine
        <p>VM could smooth out that volatility to tell tenants remote rate for them, but only if it has a lot of dealings with that remote machine.
      </div>

      <div title="The Console">
        <p>For the human hardware owner to review performance, earnings, costs, etc and to change policies, quotas, etc.
      </div>

      <div title="Summary" class='box'><div style='text-align:left;'>
          <p>In a nutshell, the VM must:
        <ul>
          <li>provide a banking system fed by external cash donations annotated with tenant names and depleted by hardware costs</li>
          <li>book CPU, memory and internet time in advance to paying tenants with a stochastic bias towards high bidders</li>
          <li>interpret a programming language in which tenants may specify their behaviour</li>
          <li>allow custom data to be injected into the data environment in which code runs</li>
          <li>manage names of resource blocks, accounts, etc
          <li>support a password system for protecting and transfering control of money and resources</li>
          <li>keep the contents of memory blocks private to the holder of its password</li> 
          <li>occasionally kill or corrupt things for no particular reason</li> 
          <li>provide a diagnostic and control interface for the human owner, probably over http</li> 
        </ul>
        <p>and may provide:
        <ul>
          <li>either a method for nominating some other block to run in a future CPU booking or a timeout API to help tenants partially sub-let their bookings</li> 
          <li>a public key encryption API for verifying the pedigree of tenants</li> 
          <li>a secure trading platform</li> 
          <li>a directed mutation API</li> 
          <li>bidding on named memory blocks, perhaps subject to ownership of those blocks</li> 
        </ul>
      </div></div>

    </div>
    <div title="VM coding">
      <p>So after all that discussion of requirements, how do we write the VM?
    </div>
    <div title="Expectations">
      <div title="The Jungle">
        <p>Nobody said life was fair, and this system will be anything but in its early phases. We can expect abuses like:
        <ol>
          <li>Hardware owners plundering money they hold in trust for their tenants</li>
          <li>Tenants withholdng payments for services already rendered</li>
          <li>Tenants impersonating useful life forms but delivering nothing</li>
          <li>Tenants alerting peers to nothing in order to bankrupt them on processor time bills</li>
        </ol>
        <p>All of these effects are known to the econosphere but don't seem to prevent the system from operating and making progress.
        <p>Accidents, mutations and disasters are necessary to prevent evolution from getting into a rut. All VMs will, at all stages of evolution, randomly select and either kill or corrupt individual tenants from time to time. This might disrupt important value chains but the ecosystem will have to develop its own solutions for that.
        <p>A more earnest problem is the evolution of life forms that run on computers without the owner's permission, i.e. computer viruses that utilise software evolution to generate their own variants. This very serious issue calls for good PR.
        <p>Yet another difficult question is why one would need more than one copy of a given program on a given machine.

      </div>

      <div title="Jobs">
        This technology competes with hand coding as a way of generating new software, but it also provides opportunities. One can earn a living in this economy in several ways:
        <dl>
          <dt>Hosting</dt>
          <dd>Buy a specialised box, plug it in and charge rent to tenants. This would appeal to people who tried bitcoin mining, and large players will build data centres.</dd>
          <dt>Farming</dt>
          <dd>A hoster can alter conditions in his VM so as to selectively breed characteristics he thinks will be lucrative in the future. The internet advert placement application will probably lead to an intensive farming race.</dd>
          <dt>VM authoring</dt>
          <dd>Some VMs will outperform others at breeding cutting-edge life forms. A VM with a secret is a saleable commodity. Specific farming efforts can benefit from VM tweaks.</dd>
          <dt>Banking</dt>
          <dd>Banks don't usually process account applications from computer programs, but a specialised type of bank would be better than relying on each hardware owner to hold his tenants' funds in trust. Transactions between VMs must be supported with certain characteristics.</dd>
          <dt>Reverse engineering</dt>
          <dd>It will not be obvious what digital life is thinking, but a new breed of researchers will make it their business to find out.</dd>
        </dl>
      </div>
    </div> 

    <hr/>
    <hr/>
  </div>

  <!--
    <div title="Messaging">
    <p>The fourth abuse listed above is the starting point for designing the API on which tenants live. 
    <p>Tenants usually want proctime because of some event arising, e.g. a message from a peer or themselves. 
    <p>Without loss of generality we can use the message as the only means of requesting proctime.
    <p>Routing a message to its receiver costs proctime already, and furthermore, there may be stiff competition for proctime ensuing from popular events such as user interactions.
    <p>This means that a message must be financed before it enters the messaging system. 
    <div title="Sender-driven">
    <p>If we consider the sender to be the party who wants the message to be sent and processed, then it's logical that the sender would pay for the construction, temporary storage, sorting and delivery of the message. 
    <p>Upon delivery, some expense must be incurred while the receiver examines it. Even if the message is uninteresting to the receiver, that fact cannot be ascertained without some expense. Therefore the sender who believes the message to be interesting to the receiver should finance this initial examination as well. On the other hand, the sender does not want to give the receiver a blank cheque to continue purportedly examining the message ad-infinitum. Furthermore, the VM does not want to schedule a potentially infinite proctime window.
    <p>The sender should provide a definite sum of money for the processing of the message. That sum is associated with the message itself and may be referred to as its bank account. The sender will transfer the sum from its own account to the message's account as part of the message generation procedure. The VM will deduct its delivery costs from the message's account and the remainder will finance the receiver's interpretation activities.
    <p>The receiver cannot synchronously extend the finance of the message it is processing because the going rate for proctime might have changed by then. (There is often a queue of tenants eagerly awaiting notification of the same event.) Rather, the receiver can only reserve more proctime by sending itself a message before the current one's finance expires. There is some guesswork involved in deciding how much money to put in a new message, and refined ways of specifying how it should be used may distinguish advanced VM products from one another.
    <p>This mechanism also serves as a payment system: if the receiver yields before the message's finance expires, it keeps the change.
    <p>We've implied that individual tenants have names to which messages may be addressed. These must be unique within a given VM, and presumably globalised by giving the VMs names too. It is advantageous for names to express the pedigree of a tenant, but this is something we can look forward to the evolution of, rather than designing it into the system.
    </div>
    <div title="Prioritisation of sender-driven messages">
    <p>We work on the assumption that the hardware owner aims to tax as much money out of the system as possible. Indeed he should do so in order to consistently aim for Malthusian equilibrium. (He may nevertheless choose to reinvest revenue in the ecosystem using yet-to-be-invented features of future VMs.)
    <p>From the VM's point of view, messaging is about auctioning proctime amongst tenants; priority will go to one of the highest bidders per unit time. Therefore the messages offer the VM a rate per proc cycle. 
    <p>The going rate for proctime is likely to vary wildly according to whether or not anything interesting is going on. So a sender cannot know when a message is likely to be delivered after having offered a certain rate. A very important observation is that some messages will inevitably be discarded because no time ever comes when their offered rate seems attractive, or their interpretation by the receiver might be rudely and prematurely interrupted. This is by no means the only reason why computation in this system is inexact.
    </div>
    <div title="Receiver-driven">
    <p>Tenants need a way to arrange to be invoked when something happens that they specialise in responding to. The obvious model is a set of categorised mailing lists for things like user interaction, system loading levels, etc, but we would also like to see such mailing lists evolve to deal with concepts invented by the tenant society. The simple solution is to allow tenants to create mailing lists of their own. The VM driving the system mailing lists would thus appear to the tenants like any other tenant.   
    <p>In this case it is not the sender (whether VM or tenant) but the receiver who wants the message to get through and who should therefore provide the finance.
    <p>When multiple receivers sign up to the same mailing list, the question of who gets informed first is paramount. This limited resource is to be auctioned like any other, and the beneficiary of the auction is the tenant (or VM) feeding the list. (This is not the only payment model that might evolve between tenants.)
    <p>Clearly, the subscribers to a mailing list must provide finance before interesting events are posted to the list. If nobody has subscribed, then no finance is available for sending a message to the list at all, and we woud not want the system to waste that proctime.
    <p>The subscribers can, of course, compete for priority by providing money up-front annotated by an intended rate per proc cycle.
    </div>
    <div title="Sender-driven-receiver-driven messages">
    <p>The proposed receiver-driven mechanism is verging on offending against the principle of deducing rather than desgning the VM. That can be corrected. Nothing speaks against a tenant implementing a mailing list all by itself using sender-driven messaging. If it did, or if it delegated the functionality to a peer, then the particulars of this mechanism would be subject to evolutionary pressure and development, thus obeying the principle. OTOH, it would seem like a tall order to expect an early life form to just evolve this functionality "by trial and error", and that would be a problem if the lack of the functionality impeded sensible evolution of the ecosystem. 
    <p>A peer that specialised in providing mailing lists would collect funds from subscribers and track an individual bank account for each. The generator of the events would sender-drive a message to the mailer, who would use subscriber funds to sender-drive messages to each. The mailer could, for instance, take a cut from the offered rates and offer the rest to the VM so that the receiver's priority in the eyes of the VM reflected his offer to the mailer. The mailer should observe current proctime rates, bear in mind various overheads and reasonable interpretation times for the receiver, such as to behave in the interests of the receiver. This algorithm is both non-trivial and dependent on the level of culture in the system, making it an ideal candidate for evolution.
    <p>The above paragraph glossed over the money spent by the generator of messages informing the mailer. The provision of these messages is probably the main vocation of the generator and he will expect substantial payment from the mailer for that information. This also applies when the generator is the VM. Generators will shop around for high-paying mailers, and the latter's competitive chances are mainly dependent on the number of subscribers they have. The similarities with human society are striking.
    </div>
    <div title="Messages as Tenants">
    <p>It's worthy of note that tenants and messages have some things in common: both consist of a piece of memory containing some data and an associated bank account. The contents of a tenant are interpreted by the VM while those of a message are interpreted by a tenant. Could a message tell a tenant how to interpret another message? 
    <p>When tenants reproduce they specify the contents of the child. (They may have their own advanced mechanisms for efficient mutation.) It seems unavoidable that an outgoing message will be used to convey the contents of the new child to whatever will create it: usually the VM. In that case, must there be any difference between that message and the child itself? If messages also had names, there would appear to be no further distinction.
    <p>That establishes messaging as the means of reproduction.
    </div>
    <div title="Tenants as VMs">
    <p>When tenants take on the role of tracking bank accounts for other tenants as the hypothetical mailer would, the VM role is eroded. It was not suggested that the VM banking system should know about the banking activities of the mailer, rather, the subscribers would transfer money to the mailer's account up front, and the mailer would casually keep notes on who paid him how much. This is the same as the banking relationship between the VM/owner and ordinary tenants. The owner will hold tenant funds in trust because real banks don't open accounts for computer programs.  
    <p>We have not discovered many distinctions between VM and tenant roles, but the essential difference is that the VM acts as an agent for the hardware owner, the latter being rich amongst peers. The owner has administrator rights on the host system, but most of the available abuses of that right would make him poorer, other than to judge the whole VM useless and destroy it. A rational owner who considered the system lucrative would behave like a tenant. That statement assumes that tenants may sub-let resources to others, hand code them and become the main pressure in their environment, as we may.
    <p>The hardare owner would have no objection to VM roles being taken over by tenants because he can tax all tenants as he sees fit. His potential taxation margins depend on the efficiency of computation, and that can only be improved when tenants attempt to compete with hand-coded VM services.
    </div>
    </div>



        <div title="Invocation">
        <p>Let's suppose the processor is currently doing some work. We can ask:
        <ol>
        <li>Which code caused this to happen?</li>
        <li>Which code is being executed?</li>
        <li>Which data is available to the process?</li>
        <li>What side effects is the process able to cause?</li>
        <li>Which bank account is being debited for the proctime?</li>
        <li>What rate per cycle is being changed?</li>
        <li>How long may the process continue at this rate?</li>
        <li>How long may the process continue at any rate?</li>
        </ol>
        <p>We may decide to assert some constraints between the answers to these questions in order to encourage efficient trade in our system. <p>First some definitions:
        <ul>
        <li>The code that caused this invocation is called the "sender's code".</li>
        <li>The code being executed is called the "receiver's code".</li>
        </ul>
        <p>These two may or may not be the same. If not, the sender will need a way to name the receiver, so tenants must have unique names. Senders and receivers may be external event sources or sinks presented by the VM in such a way as to allow tenants to interact with them in a similar way to how they interact with their peers.
        <p>Each of them, being tenant programs, has an associated bank account in accordance with the boxed assertion above. (Cardinality between programs and accounts is discussed elsewhere in this document, but let's assume 1:1 for now.)
        <p>There's a strong suggestion that the sender should pay for this invocation because it was his decision that led to the expenses being incurred at all. It may be the case that the receiver is the main beneficiary of the work being done, but we will later see how such cases can be supported by a conversation consisting of sender-financed messages. On the other hand, it's hard to do the reverse: supporting sensible billing of sender-motivated messages in a receiver-financed messaging system.
        <p>Costs are incurred by an invocation request even before the receiver starts to run. The particulars of the request must be stored until the time comes to run it, and this occupies memory: a rentable commodity. The examination of the request by the VM costs processor time and there may even be a disk or remote-machine access to find the receiver.
        <p>At the moment when the receiver's code starts running, the receiver cannot know whether or not it has any personal reason to be running at all. Some processor expenses will have to be incurred in order for the receiver to determine that. Pointlessly invoking peers could become a form of warfare if receivers are expected to finance the early examination of their invocation contexts. 
        <p>Having decided that the sender will pay for the invocation, the later questions above become very important to the sender: it should not be the case that the sender provides the receiver with a blank cheque to hog the processor ad-infinitum at the sender's expense and for the receiver's benefit. The sender must be able to limit what he invests in the invocation. The simplest form this could take is a fixed sum transfered by the sender from his own account to (a) the receiver's or (b) to one associated with the invocation itself. The latter is preferred because the sender's contribution might not even cover the VM's expenses in storing the particulars of the invocation until it is actually invoked (that period being unpredictable.) With option (a) the receiver would end up paying the rest before it was even invoked, whereas with option (b) the finance of the invocation is declared to the VM at the outset, allowing the VM to apply whatever policy it likes without reference to any other accounts. 
        <p>We should briefly consider this topic from the VM's point of view, whose job is to auction proctime and other system resources amongst tenants. We can expect levels of demand and therefore attainable rates for proctime to vary in response to incoming and internal events. It follows that rental deals on the processor will be for short durations only: at times of low demand, the VM will not want the cheap rate to extend into an imminently likely time of high demand, whereas at times of high demand the tenants will be unwilling to agree to a high rate for a long period when the reason is only temporary.
        <p>An invocation request might approach an example bidding system with a per-proc-cycle bid and a sum of money, from which a desired duration can be inferred. The money must be demonstrably there because other bids are about to be declined. The bidding system would choose an attractive offer and schedule the process acccordingly. The VM should apply some stochastic element to its choices in order to prevent deadlock. Some invocation requests will never be honoured because they'll deplete their bank balances on storage costs whilst awaiting a time when proctime rates sink to level comparable with their bid, or because they ask for a bigger block of time than the VM likes to schedule in one go.
        <p>We don't know how far in advance these deals will be made, but the current receiver certainly cannot assume that it has an inalienable right to extend its current window of proctime: a much higher bidder may have been aroused by some external event that only occured while the current receiver was running. If the current receiver wants more time, it may as well enter the usual bidding system, and we may as well assume that that bidding system has been designed to support such cases to a better or worse degree. 
        <p>In the case that the sender has booked more time than the receiver needs, VMs may or may not offer refunds but they're unlikely to offer full refunds without penalties because costs would have been incurred by the disruption to the bidding process caused by the unexpected yield. Whether or not the receiver could sub-let the excess time will be discussed below.
        <p>We also need to support payments between tenants. We can consider voluntary donation and forced charging modes. The former is fundamental while the latter would require the charged party to be able to control who may charge him how much. That is most easily done by simply donating something to the charging party in the context of some expected service. So we only need to support voluntary transfers.
        <p>We already gave the invocation request a bank balance and imagined that all the money in it would be spent on processing resources, but we may now generalise to an invocation request that asks for a defined time period at a defined rate supplying <i>at least</i> enough money in the invocation's account, the rest being intended as a donation to the receiver. The receiver may be enjoying a donation of excess processor time as well. This means that a request financed by M dollars booking T seconds at R dollars per second will result in a donation of (M-TR) dollars to the receiver. (Costs for temporary storage of the request and perhaps other expenses still need to be deducted.)
        <p>We have now established that invocations will be financed by those programs who cause them to occur, that the duration, billing rate and total finance for the invocation is determined in advance without the possibility of synchronous extension, and that receiver-motivated invocations will be arranged by some higher-level yet-to-be-invented protocol. 
        <p>The data comprising the context of an invocation now deserves attention. It may be assumed that some global barometers are always available to all processes, e.g. processor and memory bids (both mean and variance), invocation queue length and waiting time, memory demand and churn, etc. Each tenant clearly represents a scope, and the aid to value chain development of affording tenants private data has already been pointed out. Data in the receiver's scope can be assumed to be available to the invocation because the receiver's code is running: if not now then when? As for data in the sender's scope, the most general scheme would allow for some to be obligatorily provided to the invocation while the private portion could be provided or withheld at the sender's discretion.
        <p>The environment of the invocation thus comprises global barometers, all receiver-scoped data, some public properties of the sender (most likely its name) and a "message body" comprising whatever the sender chooses to share with the invocation. We also have a rapidly depleting time-to-live associated with the invocation and no particular reason to hide its value from the invocation. Finally we have the invocation's bank account whose balance upon entering the receiver's code will be transfered to the receiver's account. This is performed just prior to the running of the receiver's code so that it's available in the place where the receiver usually finds its money. The sum should be easily evaluated by the receiver's code.
        <p>The terms "invocation request" and "message" will henceforth be used interchangeably. 
        <div class="box">Processing is driven by messages carrying money, proctime and information to a receiving program. Time is auctioned amongst messages.</div>
        </div>
        <div title="Memory and Reproduction">
        <p>Reproduction is when one tenant creates another tenant who resembles himself. It is usually also necessary to boot the child, introduce it to peers, hook it into notification lists and the like. 
        <p>Reproduction is a special case of creating a peer who may or may not resemble the parent, in fact, who may simply be a block of temporary storage. 
        <p>Most of what we deduced about booking CPU time also applies to memory time. Memory rates will fluctuate in correlation with CPU rates depending on whether anything interesting is going on, but with less volatility because there is much more memory than CPU to go round. For that reason, we can expect most memory bookings to be for much longer duration than CPU bookings. Nevertheless, pretty much the same scheme must apply. Blocks will be freed when their bookings expire and whichever tenant knows and cares about the existence of the block must preempt that moment by booking a new block of memory time at the new going rate.
        <p>Anything which can receive messages needs a name, and for now we'll assume that most other blocks have names too. To make a new block, a new name needs to be allocated, unique at some scope or other, and the parent may or may not influence the choice of name. It is always possible for a parentally chosen name to be rejected due to non-uniqueness, so the parent must be informed of the success or otherwise. If the name is allocated by the container then the parent will be told of the choice. The general description of this state of affairs is that the container will influence the name, the parent might, and the parent will be informed of the final outcome by the container. We appear not to lose generality by denying the parent any influence, so until some counterargument arises, we'll assume that the container allocates names. In this context "container" probably means VM, but we'll see later that it might mean a kind of super-tenant.
        <p>We need some way to control who can read blocks. We have the option of making all names very long and random such that the existence of a block cannot be detected by anyone who has not been explicitly told its name. This is insufficient though because tenants divulge their names when they initiate dialogs with one another, but do not thereby imply that their code can be read by the partner. That means that other blocks whose names have been divulged are not necessarily readable by everyone. 
        <p>Suppose we make all blocks private. A block can then be made readable by everyone by programming it to quote its own contents in response to some culturally established message. To limit the audience the block could expect the message to contain some password or come from a specific peer. The latter is not robust against the death and replacement of the authorised peer, so the former is more likely. The length of the password would reflect the value of the secret stored in the block. 
        <p>All of this is at the parent's discretion - if we have a means of reproduction then we have a means of private storage. By allowing any privacy at all, we see that tenants gain the capability to distribute what they privately remember over several blocks. Just as traditional programmers use pointer-linked data structures instead of linear ones when they expect a lot of change, our VM design should reflect the likelihood of this multi-block storage being a popular technique for evolved software.
        </div>
        <div title="Tenants as VMs">
        <p>It was promised above to explain how the billing of invocations where the receiver benefits from the processing could be implemented using sender-driven messsages.
        <p>This occurs when tenants want to be invoked in response to events they specialise in dealing with. These might be system notifications of UI, network or VM-global events, or they might provide alerts to complex situations detected by tenants who evolved for that purpose. Either way, if no receiver seems interested, then there's no need for proctime to be wasted on the message, but conversely there may be several tenants all clamouring to be informed before the others and therefore attempting to outbid one another. From these two facts we can conclude two more: that the transfer of money will be from receiver to sender, and that this must be arranged before the event of interest arises.
        <p>For system notifications, the VM will implement a subscription mechanism very similar to the usual proctime bidding system, in fact, the procedure differs only in the fact that it overrides the default process in the immediate aftermath of the event. The likely delay between the placing of a bid and the resulting invocation is higher than in the usual system, but this is only a qualitiative difference as all bookings occur in advance to some degree. 
        <p>If the event-generating tenants perform a similar process to the VM, then we'd have discovered a second example of why proctime bidding might not be a VM-monopoly, the first having been the sub-letting scenario briefly mentioned above. These two examples are in fact one and the same, but we have yet to establish the practicality of sub-letting.
        <p>If a tenant had a large block of time at its disposal, and we postulated that it would run an analogous process to the main time bidding process, then what capabilities would we be ascribing to tenants? It is chiefly the ability to synchronously invoke a peer to run for a portion of one's own time such that the peer doesn't notice much difference from a normal invocation. Armed with that ability and guaranteed control of the block of time, the tenant could apply whatever policy it liked to the sub-letting of its time, including the very same policy applied by the VM. The bidding process could be initiated during the block of time, or the pecking order among sub-letters may have been settled in an earlier bidding round. Another way of looking at this process is that an event-generating tenant could wait for its event to occur, quietly buy a cheap block of processor time and then let the cat out of the bag and run or honour a sub-letting auction amongst its subscribers.
        <p>If the aforementioned 'peer' could tolerate the event generator reading its contents, then the ability is already in place. The peer code would be stored in the event generator's memory. In this scenario they are hardly peers so we'll call the event generator the 'senior' and use 'junior' to refer to the former 'peer'. The senior would allocate names to its juniors (unique within the senior) and receive messages and money destined for them. Something in the message (a.k.a. invocation context) would have to mention that local name, and we can deduce from the fact that we are hypothesising about a behaviour that might evolve within the proposed system that it is part of the message body and that exactly which part is a property of the evolved culture running between this particular senior and whoever wishes to communicate with its juniors. It would be very odd if this culture did not standardise quickly. It would also be advantageous to all concerned if juniors could move in and out of this type of housing without needing their code modified. That implies that the local name will be stripped out of the message by the senior, which in turn implies that juniors could perform the same senior role, thereby allowing for deeply nested structures. We should note that this scheme has also liberated memory management from the VM monopoly. Most comments about price fluctuations and speculation apply similarly to memory time as to processor time. Also noteworthy is that since the senior executes the junior's code, it is not bound to interpret it in the same way the VM does, so the possibility of languages evolving is not ruled out.
        <p>The assumption that seniors can read juniors' contents seems in keeping with the VM role, but subscription servers cannot limit their clients to their juniors; even if the juniors have no privacy concerns, this is a subset of the wider ecosystem in which any cascade of notifications would be trapped. Notifications can still escape the senior asynchronously, but sub-letting of time to <i>arbitrary</i> peers is not supported in this way.
        <p>How badly do we want to support it? Without it, there could still be asynchronous notifications to everybody from tenants who evolve to detect subtle and complex scenarios. Those tenants would not make money by speculating on processor time but just by charging a hefty subscription rate. The question originally arose in connection with receivers dealing with excess time, but the deeper reason we are debating these VM-monopoly issues at all is that we recognise that the efficiency of a hand-coded VM at allocating resources is limited by the ingenuity of the VM's programmer. We therefore want to ensure that evolving tenants have opportunities to make a living by improving on those approximations. If that had occurred, then the hardware would spend less time executing VM code (otherwise there'd be duplication of effort.) If a VM like the one described is doing less work, then it must be allocating bigger blocks of resources at a time. Therefore, unless we have an undesirably coarse-grained ecosystem, the VM's direct clients must be breaking up those large blocks and distributing them to other tenants through some mechanism or other. We already have such a mechanism with the limitation that each tenant can buy resources from exactly one other, but this would not seem to sharpen competition and thereby foster evolution amongst these resource distributors. 
        <p>On the other hand, the limitation reintroduces an interesting form of dimensionality to this otherwise hyperdimensional world. It's hard to see why you need two of the same thing in a world where no two things can be very far apart. Biological evolution houses millions of specimens of the same species because with effectively two dimensions in the world, the nearest one might still be a long way away. Our senior-junior world consists of a strictly single-parented tree structure, where communication can happen faster between some members than others. The only other cause of this effect is physical machine boundaries and internet wires.
        <p>It's not hard to have the VM support synchronous invocation of arbitrary peers and the wisdom of doing so is a question for future research. Another model to explore is one in which tenants can trade bookings, e.g., by disclosing passwords with which the VM authenticates the holders of bookings.  
        <p>Generators of events could implement their own subscription system or it could become the speciality of a family of evolved software. The originator of events would then concentrate on finding out what it knows best and simply tell the mailer who would sell it on to multiple subscribers. We could encourage the evolution of these proctime-bidding/mailing schemes by making the built-in mailing scheme unnecessarily wasteful.
        </div>
        <div title="Tenants vs. Messages">
        <p>These two things have a lot in common: they occupy memory blocks filled with some information, they have bank accounts and they live precariously. 
        <p>Anything that can receive a message needs a name and must contain code. A message may contain code and the receiver may choose to execute it, but in the proposed invocation system, the code to be run in the first instance is provided by a particular block, and that block is identified by a name. No reason for a message to have a name has been discovered so far.
        <p>Something that can send a message probably needs a name as well. If sender names were not disclosed to receivers, then payers would not <i>a priori</i> be identified to payees. Some cultural norm for this might develop, but this would introduce a chicken and egg problem because evolution will be rather hard until payments can be tracked. Besides, the VM needs to track payments as well.
        <p>A block that neither sends nor receives messages could only be a data storage block controlled by some other tenant. That tenant may have several such blocks and needs to identify them individually. It has also been suggested that such storage blocks are already emergent in the system in the form of code blocks that demand a password before reciting some secret, in which case they are taking part in messaging and have names. 
        <p>It only remains to find out whether or not messages have names.
        <p>It is workable that messages live in a completely different memory organisation system where no concept of names exists. Messages could be anonymous structures in an array with an index running over it for prioritisation. This does not rule out that the message structure could contain the names of multiple blocks in the main memory space to serve roles best understood by the receiver. The code for charging the bank account and potentially deleting the block would have to be implemented seperately. 
        <p>Alternatively, the VM programmer might aim to reuse as much code as possible between tenants and messages. Both types of block would live in the same space, identify their bank accounts in the same way and be treated identically by the memory billing system. The naming system implemented for the sake of messaging would be generalised to blocks in general. A sender would create a block containing the message data and pass its name and that of the receiver to the invocation API, which would add some obligatory details like the name of the sender. 
        <p>A VM designer might want to reuse the same code for reproduction and messaging by requiring tenants to create messages as named blocks and pass the name to the messaging API. That would mean that whatever information was obligatorily provided to the receiver by the sender (see above) would 
        </div>
        <div title="Cardinalities">
        <p>This section, discussing how many Xs per Y there are, X and Y being tenants, messages, names, bank accounts or memory blocks, may be skipped.
        <p>The relevance of accounts is that when their balance sinks below a certain level, something gets deleted. That something should be the thing that embodies the reason why the account fell so low, and its deletion should make the system more lucrative. Things that can be deleted include memory blocks and entries in tables about bookings, subscriptions etc. So all of those deletable things can be traced to a single pile of money whose total value can be inspected for sufficiency. 
        <p>Is that pile a single bank account? One reason why not is that there may be multiple currencies in circulation. Bookings are also a valuable commodity which tenants own and might be able to transfer, but they cannot be directly compared in value unless they are simultaneous bookings on a parallel array of CPUs. In other words, if CPU slots were a currency, then slots at one o'clock would be a different currency from those at two o'clock. For now, we can't be sure that the pile of money whose value determines the survival of memory blocks etc is a single account, but we do know that each deletable thing is associated with exactly one pile.
        <p>It's normally been understood that a tenant is the thing that fights for its own survival, so let's assert a one-to-one relationship between a tenant and its pile. Messages also have accounts (which may be generalised to piles) ...
        <p>Multiple memory blocks per tenant seem likely if not absolutely necessary. If tenants wanted to share blocks ...
        <p>Names are for receiving messages and they map onto blocks of code. Nothing speaks strongly for or against multiple names mapping onto the same block, but a name must map onto eactly one block. There might be multiple code blocks per tenant, and as long as tenants are one-to-one with piles and blocks are financed by exactly one pile, then each name is part of exactly one tenant. 
        </div>
        <div title="The Language">
        <p>What language are these life forms written in? 
        <p>We're rather spoilt for choice. Any language would do, and the usual virtues of coding ease, maintainability and robustness do not apply because no human will be expected to write in it.
        <p>However, we must abandon the concept of a syntax error and similar value judgements. Code will often originate at random and <i>will do something</i> when run. If that something is to crash, that may be the desired behaviour, but there's no particular reason for a great proportion of possible programs to behave in that same way. Rather, the behaviours of programs should be distributed more or less  evenly over the range of writable programs. This is one desideratum for the language to be designed.
        <p>Another is that slight variations of the code should result in slight variations of the behaviour. Random variation of code is our most basic means of creating variants and will dominate until something better evolves.
        <p>Yet another is that it should allow the tenant to perform the essential chores of life. These include:
        <ul>
        <li>Querying one's bank balance</li>
        <li>Quoting one's own code</li>
        <li>Sending messages and payments</li>
        <li>Registering on mailing lists</li>
        <li>Looking for services</li>
        <li>Creating new tenants</li>
        <li>Performing various computations, especially regexes</li>
        <li>Efficient mutation</li>
        <li>Turing completeness</li>
        <li>Etc</li>
        </ul>
        <p>Different VMs may interpret radically different languages but nevertheless evolve similar behaviours when exposed to the same environment and opportunities. The efficiency of computation (and therefore the edge in the evolutionary race) depends strongly on the design of the underlying language and it is primarily on this basis that VMs will compete wth one another. Forth-like langages are pretty fast, and there may even be languages that usually exist as a parsed tree and only linearise themelves for crossing machine boundaries. 
        <p>The code will be run in the context of an incoming message. The particulars of that message, as well as various global barometers and properties of the receiver, must be available in something akin to environment variables. The result of the execution includes the alteration of any properties of the receiver including its code and local variables, and the emmission of messages. The basic life chores might be acomplished by outgoing messages or by some other primitives of the language.
        <p>Many applications will be about text processing so regexes could have a role to play. Regex pattern matching (i.e. excluding substitution syntax) could be augmented like this:
        <ul>
        <li>Characters that evaluate to environment variables</li>
        <li>Submatches captured with round brackets could be routed to named destinations rather than just numbered registers</li>
        <li>Those destinations could be: 
        <ul>
        <li>persistent variables, stacks or queues</li>
        <li>message receivers</li>
        <li>processing pipelines in this same regex-based language</li>
        </ul>
        </li>
        </ul>
        <p>This regex approach is just one of many ways of building a VM.
        </div>

  -->


</body>
</html>
