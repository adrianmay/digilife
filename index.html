<html>
<head>
  <title>Digital Life</title>
  <style type="text/css">
body {margin-left: 330px; font-family:Arial}
h1 {text-align:center}
h2 {padding-top:30px;padding-bottom:20px;}
h3 {padding-top:20px;padding-bottom:10px;}
th {text-align:left}
h1,h2,h3,h4 {text-decoration:underline}
h1,h2,h3,th {text-transform:uppercase}
dt,th { font-weight:bold; }
td, th { vertical-align: top; padding-left: 5px;}
.box {text-align:center; background-color:#DDFFFF; margin-left:15%; margin-right:15%; border: 1px solid grey; padding: 10px;}
  </style>
</head>
<body>

  <div title="Digital Life" style="border:8 #FFFFFF solid; cellpadding:1; background-color:#FFFFFF;">

    <div title="Goal">
      <div class=box>Intelligent, useful, internet-native, <b>freely evolving software life-forms</b> permanently established in world economy.</div>
      <p>... meaning? ...
      <dl>
        <dt>Freely evolving life-forms:</dt>    
        <dd><p>No predefined goal or value judgments except survival under Darwinism. Results unpredictable. Not genetic algorithms. </dd>    
        <dt>Internet-native:</dt>    
        <dd><p>Optimises itself for survival on the internet. Does not play chess, simulate worms or fishmongers or pretend to be human.</dd>    
        <dt>Useful:</dt>    
        <dd><p>Not a virus: stays on computers with the permission of humans. Therefore must deliver some utility or make money for computer owner.</dd>    
        <dt>Intelligent:</dt>    
        <dd><p>Not Turing Test. Does not perform preconceived tricks. Creatively finds own solutions to own problems within its own evolutionary strategy.</dd>    
        <dt>Established in world economy:</dt>    
        <dd><p>Otherwise its strategy would not be stable; it would merely be a lab demonstration, not a mature life form.</dd>    
      </dl> 

    </div>
    <div title="Philosophy">

      <div title="Fears">
        <dl>
          <dt>Will it take over the world?</dt>
          <dd><p>It has long been the case that the world is largely controlled by algorithms. It doesn't make a difference that many of them are implemented by computers. These algorithms drive the stockmarket and thereby decide how many people a company can employ, and thereby control what most of us do all day. Companies themselves are Darwinian entities but very different from humans. That they are composed of humans is of as little consequence as the fact that humans and goats are composed of the same type of cells. So it's a fallacy that humans control the world today or that an increasing role for software would change anything.</dd>
          <dt>Will there be a war like in "Terminator" or "I Robot"?</dt>
          <dd><p>The proposed digital life lives inside a VM where it can communicate with its peers and any humans who are interested. It won't be put in direct control of any machinery, but we will become dependent on its advice. This dependence will be mutual because a computer program cannot build its own computer. There seems no reason to trust this mutually beneficial relationship less than any other.</dd>
          <dt>Will it be conscious?</dt>
          <dd><p>The problem with this question is that it can never be answered; there's no test for consciousness. That's why people's estimation of the consciousness of animals, foetuses and even women has varied wildly through the centuries. There are more refined versions of this question involving terms like "self-awareness", "free will", "creativity", etc, but such terms are either undefinable and untestable or mere software features.</dd>
          <dt>Should we be nice to it, like in Blade Runner?</dt>
          <dd><p>It could have as much claim to consciousness as any similarly complex machine, and the entire network may grow to dwarf the complexity of a human mind, but any internal experiences it might have will not resemble our's in the slightest. We'd have more to talk about with, say, a spider than one of these digital life forms, and they won't be half as cute as polar bears, so the chances of humans empathising with digital life emotionally are slim. Besides, shouldn't we start by learning to be nice to other humans?</dd>
          <dt>Is this like playing God?</dt>
          <dd><p>If you're an atheist, that won't worry you, but if you're religious, you'll be glad somebody decided to play God for the world we live in. Why shouldn't somebody else play that role for a new world in which something else will live? <p>Religious people will find it interesting that this project needs the equivalent of natural disasters to make it work, that being one of the stickiest questions posed by atheists. On the other hand, they'd be dismayed by ithe idea of a god who expected his creations to surpass his own intelligence and power.</dd>
          <dt></dt>
          <dd></dd>
          <dt></dt>
          <dd></dd>
        </dl>
      </div>
      <div title="What is Intelligence?">
        <dl>
          <dt>Purpose: Help preserve life; meaningless outside of that context</dt>
          <dd><p>For instance, AI people like to build pattern recognisers that respond differently to trained images of e.g. houses and trees. However, humans generally ignore both of these everyday objects whilst responding strongly to unfamiliar stimuli. In the light of the energy cost of cognition (which most biological life forms found prohibitive) this is the desired functionality. The AI researchers made that mistake by trying to take intelligence outside of its life-preserving context.</dd>
          <dt>Not artificial schizophrenia</dt>
          <dd><p>Lifeforms are not expected to impersonate other species, especially not radically different ones. A software that attempted the Turing Test (a challenge in which a program attempts to pass as a human) would be making this highly unintelligent mistake. Such a bizarre program could potentially be designed but would never evolve freely.</dd>
          <dt>Start with the nematode</dt>
          <dd><p>This highly successful arthropod's control system consists of roughly 300 neurons and 7000 pre-wired synapses which have now been reverse engineered in intricate detail. Nematodes exhibit hunger, satisfaction, fright, exploration, a sense of direction, and short term learning. Higher forms of intelligence should be understood as stepwise developments of this one, the steps having been justified by some identified need.</dd>
          <dt>The computational substrate doesn't matter</dt>
          <dd><p>Given that some machine can learn by trial and error or internal simulation of the same, the behaviours it will adopt are those that succeed in its environment. This is not affected by whether the machine is based on neurons, transistors or any other computational machinery. For this reason, it is of no consequence that this AI project is not based on neuronal computing.</dd>
          <dt>Memes</dt>
          <dd><p>Evolution of Ideas. Thoughts, beliefs, habits, words, religions, technologies, etc are observed to gain popularity or be forgotten in accordance with Darwinian dynamics.
          <p>Proposed within sociology by Herbert Spencer ~1857. 
          <p>Generalised to individual cogntion by Richard Dawkins ~1976 by pointing out the plurality of (sometimes contradictory) ideas that make up an individual psyche and the energetic attempts on the part of those ideas to reproduce into other peoples' minds even at the expense of the interests of the host human. 
          <p>Either way, not based on <i>random</i> variations like biological Darwinism. Another project might attempt to establish random variations in neuronal firing as the origin of intellectual ideas, but that is not the focus here. 
          <p>If we accepted that our psyche consists exclusively of memes acting in their own evolutionary interest, and that our own interest is merely an illusion generated by memes in order to gain control of our actions, then we would have settled on a version of Zen.
          <br/><br/><div class="box">This project sees brains, societies and computers as VMs in which Darwinian evolution of behaviours can take place.</div><br/>
        </dl>
      </div>

      <div title="Comparison of worlds">
        <table width = "100%">
          <tr>
            <th width="20%">Criterion</th> 
            <th width="20%">Biosphere</th> 
            <th width="20%">Brain</th> 
            <th width="20%">Society</th> 
            <th width="20%">Computers</th> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td>Inhabitants</td> 
            <td>Animals etc</td> 
            <td>Behaviours, ideas</td> 
            <td>Behaviours, culture</td> 
            <td>Programs</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td>Space</td> 
            <td>Land</td> 
            <td>Stimuli</td> 
            <td>Believers</td> 
            <td>Memory, events</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td>Size</td> 
            <td>10<sup>9</sup> km<sup>3</sup> of ocean</td> 
            <td>10<sup>11</sup> neurons, 10<sup>15</sup> synapses</td> 
            <td>10<sup>10</sup> people</td> 
            <td>10<sup>10</sup> computers, servers and phones * 10<sup>12</sup> bytes</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td>Success</td> 
            <td>Population</td> 
            <td>Probability of response to home stimulus</td> 
            <td>Population</td> 
            <td>Domination of market segment</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td>Dimensionality</td> 
            <td>2.5</td> 
            <td>Moderate: Each stimulus situation is similar to a small set of other situations.</td> 
            <td>High: lots of phone numbers</td> 
            <td>V. high: many memory locations effectively equidistant with a given one.</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td>Energy</td> 
            <td>Food</td> 
            <td>Enthusiasm</td> 
            <td>Upheaval</td> 
            <td>Money (see later)</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td>Scarce material</td> 
            <td>Amino acids etc</td> 
            <td>Basic ideas</td> 
            <td>Basic ideas</td> 
            <td>Code snippets</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td>Persistence</td> 
            <td>Physical/chemical inertia</td> 
            <td>Synaptic retention (and evolved techniques)</td> 
            <td>Dogma</td> 
            <td>Memory</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td>Malthusian limits (important to cause selection)</td> 
            <td>Space, chemicals, sunlight</td> 
            <td>Practical incompatibility of behaviors</td> 
            <td>Mutual rejection of cultures</td> 
            <td>Memory, internet bandwidth, CPU time upon interesting events, UI, human goodwill</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td>Self replicator</td> 
            <td>DNA</td> 
            <td>Generalisation of a given response to similar stimuli</td> 
            <td>Gossip</td> 
            <td>memcpy</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
          <tr>
            <td>Accidents (important to prevent stasis)</td> 
            <td>Natural disasters, mutations</td> 
            <td>Forgetfulness</td> 
            <td>Misunderstandings</td> 
            <td>Must emulate in VM</td> 
          </tr>
          <tr><td colspan=5><hr/></td></tr>
        </table>
        <div class="box">Evolution is guaranteed to happen in any system that has an imperfect self replicator and limited resources.</div> 
      </div>

      <div title="Free (as in freedom) VM">
        <p>This system is not useful but illustrates unsupervised software evolution. Code at github/adrianmay/digilife.
        <ul>
          <li>Boot normal PC into protected mode.</li>
          <li>Single writable memory segment for code & data.</li>
          <li>Fill with large program written at random.</li>
          <li>Interrupt periodically and randomly flip bits.</li>
          <li>Exceptions just jump back to random position.</li>
          <li>Detect life by measuring compressibility.</li>
          <li>Get bored of it. (No utility. Can't understand it. Drinks electricity.)</li>
        </ul>
      </div>

    </div>
    <div title="Coding">

      <div title="Useful VM">
        <p>Definition: one that won't get switched off due to lack of utility in the eyes of the computer owner.  Notice that this definition extends the Darwinian criterion to the VM itself. The goal of this project should now be clear: it's not a lab toy, its a life form adapted to the current world of humans and computers.
        <p>Rather than designing it, let's try to deduce what it must be like. The danger of design is that it might arbitrarily limit the future possibilities to things which the designer expected, rather than allowing for the full range of things which might be discovered by an evolution-based intelligence higher than his own. We should prefer VMs with more general capabilities unless something speaks strongly in favour of a restriction.
        <p>Why would the computer owner keep a software on his computer although it consumes memory and electricity? There can only be two reasons:
        <ol>
          <li>It serves him.</li>
          <li>It serves somebody who pays him for those services.</li>
        </ol>
        <p>That somebody must have money, but must not necessarily be human.
        <p>In case 1, we can seperate the owner's role as a consumer from his role as a hardware owner, leaving two roles:
        <ol>
          <li>Hardware owners spend their own money maintaining machines on which digital life runs, whilst selling the services rendered by the life to...</li>
          <li>... consumers who pay the hardware owners for the utility rendered by the life.</li>
        </ol>
        <p>It's now pretty clear what kind of life-hosting VM will be selected by hardware owners. It should make the expensive and limited processing resources available to the most lucrative tenant life forms whilst culling any species whose resource consumption exceeds its earnings. Simultaneously, it should not rule out team work between tenants. But how? 
        <div class="box">It should track a bank account for each individual tenant program and auction processing resources (memory, proctime, internet bandwidth, GUI, early notifications) to the highest bidder.</div> 
        <p>An accurate VM will attempt to get paid for all of the resources used by the whole installed system. This should include the VM's own activities, especially when requested by a tenant.
        <p>It's healthy for the hardware owner and his agent, the VM, to try to extract the highest possible revenue from the whole set of hardware used. This is because such a policy makes the ecosystem approach Malthusian equilibrium at all times. If resources were made available for free or at an artificially reduced rate, they'd suffer over-demand and some other basis for allocation would take over, such as first-come-first-served. This other basis would be less effective at guiding evolution.
        <p>If the hardware owner cannot extract enough money from the ecosystem to pay the costs he incurrs for electricity, labour, space, depreciation, etc then he'll either temporarily put it to sleep or decommission it permanently.  
      </div>
      <div title="Value Chains">
        <p>We must now decide between these options:
        <ol>
          <li>Each tenant must earn money directly from a human.</li>
          <li>Tenants may exchange money between themselves</li>
        </ol>
        <p>It would be ridiculous to rule out tenants earning from humans, therefore case 1 above is strictly a subset of case 2. No reason to restrict the VM to case 1 springs to mind, rather, the implications of generalising to case 2 are interesting and attractive.
        <p>In case 1 each individual tenant would have to be intelligent enough to perform some saleable service all by itself. This would lead to a society of very large and delicate programs. Most mutations would break something rather than enhancing it.
        <p>In case 2 though, it is possible for value chains of many tenants to develop which would perform complex computations in a distributed fashion. This brings challenges of its own, but if the society could evolve self-organising and self-repairing techniques, then high complexity would no longer be an impediment to further evolution.
        <p>We therefore choose case 2 and notice that humans and tenants have similar rights to own and use money with this respect to this VM. Even the hardware owner could in principle be a program.
        <p>The pressure is on each tenant to deliver some needed computational service at a good price whilst facing competition. That would involve obtaining required raw information cheaply and processing it efficiently. The system is entirely analogous to capitalist economics. Some will dislike the brutally capitalist nature of this system, but I'd wager that any proposed alternative would evolve internal mechanisms that brought the rules back to the same deal. It may be palatable to start with a toy currency but an exchange rate into dollars would soon develop anyway.
        <p>A society that successfully supports value chains can be expected to have other characteristics:
        <ul>
          <li>Members should be able to defend their money and saleable assets. There may be some members with the power to confiscate assets from others, but in that case the powerful ones must refrain from plundering all of the vulnerable ones. For any trade to occur, there must be some pairs of members who cannot plunder one another. </li>
          <li> Information is a fundamental saleable asset in this system, so some tenants must be able to hide information from some other tenants.</li>
          <li>Members must be able to communicate. Whichever means of communication is used for transfering saleable information must be unobservable by non-paying listeners. </li>
          <li>Communication may occur because either the sender or the listener wants it to. </li>
        </ul>

      </div>
      <div title="Invocation">
        <p>Let's suppose the processor is currently doing some work. We can ask:
        <ol>
          <li>Which code caused this to happen?</li>
          <li>Which code is being executed?</li>
          <li>Which data is available to the process?</li>
          <li>What side effects is the process able to cause?</li>
          <li>Which bank account is being debited for the proctime?</li>
          <li>What rate per cycle is being changed?</li>
          <li>How long may the process continue at this rate?</li>
          <li>How long may the process continue at any rate?</li>
        </ol>
        <p>We may decide to assert some constraints between the answers to these questions in order to encourage efficient trade in our system. <p>First some definitions:
        <ul>
          <li>The code that caused this invocation is called the "sender's code".</li>
          <li>The code being executed is called the "receiver's code".</li>
        </ul>
        <p>These two may or may not be the same. If not, the sender will need a way to name the receiver, so tenants must have unique names. Senders and receivers may be external event sources or sinks presented by the VM in such a way as to allow tenants to interact with them in a similar way to how they interact with their peers.
        <p>Each of them, being tenant programs, has an associated bank account in accordance with the boxed assertion above. (Cardinality between programs and accounts is discussed elsewhere in this document.)
        <p>There's a strong suggestion that the sender should pay for this invocation because it was his decision that led to the expenses being incurred at all. It may be the case that the receiver is the main beneficiary of the work being done, but we will later see how such cases can be supported by a conversation consisting of sender-financed messages. On the other hand, it's hard to do the reverse: supporting sensible billing of sender-motivated messages in a receiver-financed messaging system.
        <p>Costs are incurred by an invocation request even before the receiver starts to run. The particulars of the request must be stored until the time comes to run it, and this occupies memory: a rentable commodity. The examination of the request by the VM costs processor time and there may even be a disk or remote-machine access to find the receiver.
        <p>At the moment when the receiver's code starts running, the receiver cannot know whether or not it has any personal reason to be running at all. Some processor expenses will have to be incurred in order for the receiver to determine that. Pointlessly invoking peers could become a form of warfare if receivers are expected to finance the early examination of their invocation contexts. 
        <p>Having decided that the sender will pay for the invocation, the later questions above become very important to the sender: it should not be the case that the sender provides the receiver with a blank cheque to hog the processor ad-infinitum at the sender's expense and for the receiver's benefit. The sender must be able to limit what he invests in the invocation. The simplest form this could take is a fixed sum transfered by the sender from his own account to (a) the receiver's or (b) to one associated with the invocation itself. The latter is preferred because the sender's contribution might not even cover the VM's expenses in storing the particulars of the invocation until it is actually invoked (that period being unpredictable.) With option (a) the receiver would end up paying the rest before it was even invoked. 
        <p>We should briefly consider this topic from the VM's point of view, whose job is to auction proctime and other system resources amongst tenants. We can expect demand and therefore attainable rates for proctime to vary in response to incoming events. It follows that rental deals on the processor will be for short durations only: at times of low demand, the VM will not want the cheap rate to extend into an imminently likely time of high demand, whereas at times of high demand the tenants will be unwilling to agree to a high rate for a long period when the reason is only temporary.
        <p>An invocation request might approach an example bidding system with a per-proc-cycle bid and a sum of money, from which a desired duration can be inferred. The money must be demonstrably there because other bids are about to be declined. The bidding system would choose an attractive offer and schedule the process acccordingly. The VM should apply some stochastic element to its choices in order to prevent deadlock. Some invocation requests will never be honoured because they'll deplete their bank balances on storage costs whilst awaiting a time when proctime rates sink to level comparable with their bid, or because they ask for a bigger block of time than the VM likes to schedule in one go.
        <p>We don't know how far in advance these deals will be made, but the current receiver certainly cannot assume that it has an inalienable right to extend its current window of proctime: a much higher bidder may have been aroused by some external event that only occured while the current receiver was running. If the current receiver wants more time, it may as well enter the usual bidding system, and we may as well assume that that bidding system has been designed to support such cases to a better or worse degree. 
        <p>In the case that the sender has booked more time than the receiver needs, VMs may or may not offer refunds but they're unlikely to offer full refunds without penalties because costs would have been incurred by the disruption to the bidding process of the unexpected yield. Whether or not the receiver could sub-let the excess time will be discussed below.
        <p>We also need to support payments between tenants. We can consider voluntary donation and forced charging modes. The former is fundamental while the latter would require the charged party to be able to control who may charge him how much. That is most easily done by simply donating something to the charging party in the context of some known protocol. So we only need to support voluntary transfers.
        <p>We already gave the invocation request a bank balance and imagined that all the money in it would be spent on processor time, but we may now generalise to an invocation request that asks for a defined time period at a defined rate supplying <i>at least</i> enough money in the invocation's account, the rest being intended as a donation to the receiver. The receiver may be enjoying a donation of excess processor time as well.
        <p>We have now established that invocations will be financed by those programs who cause them to occur, that the duration, billing rate and total cost of the invocation is determined in advance without the possibility of synchronous extension, and that receiver-motivated invocations will be arranged by some higher-level yet-to-be-invented protocol. 
        <p>The data comprising the context of an invocation now deserves attention. It may be assumed that some global barometers are always available to all processes. Each tenant clearly represents a scope, and the aid to value chain development of affording tenants private data has already been pointed out. Data in the receiver's scope can be assumed to be available to the invocation because the receiver's code is running: if not now then when? As for data in the sender's scope, the most general scheme would allow for some to be obligatorily provided to the invocation while the private portion could be provided or withheld at the sender's discretion.
        <p>The environment of the invocation thus comprises global data, all receiver-scoped data, some public properties of the sender and a "message body" comprising whatever the sender chooses to share with the invocation. We also have a rapidly depleting time-to-live associated with the invocation and no particular reason to hide its value from the invocation. Finally we have the invocation's bank account which will be transfered entirely to the receiver's. This is most conveniently performed just prior to the running of the receiver's code so that it's available in the place where the reciever usually finds its money. The sum should be easily evaluated by the receiver's code.
        <p>The terms "invocation request" and "message" will henceforth be used interchangeably. 
        <div class="box">Processing is driven by messages carrying money, proctime and information to a receiving program. Time is auctioned amongst messages.</div>
      </div>
      <div title="Tenants as VMs">
        <p>It was promised above to explain how the billing of invocations where the receiver benefits from the processing could be implemented using sender-driven messsages.
        <p>This occurs when tenants want to be invoked in response to events they specialise in dealing with. These might be system notifications of UI, network or VM-global events, or they might provide alerts to complex situations detected by tenants who evolved for that purpose. Either way, if no receiver seems interested, then there's no need for proctime to be wasted on the message, but conversely there may be several tenants all clamouring to be informed before the others and therefore attempting to outbid one another. From these two facts we can conclude two more: that the transfer of money will be from receiver to sender, and that this must be arranged before the event of interest arises.
        <p>For system notifications, the VM will implement a subscription mechanism very similar to the usual proctime bidding system, in fact, the procedure differs only in the fact that it overrides the default process in the immediate aftermath of the event. The bids were placed much earlier than when the invocations will occur (which increases the temporary storage costs) but scope was left for VMs to book processor time in advance anyway.    
        <p>If the event-generating tenants perform a similar process, then we'd have discovered a second example of why proctime bidding might not be a VM-monopoly, the first having been the sub-letting scenario briefly mentioned above. These two examples are in fact one and the same, but we have yet to establish the practicality of sub-letting.
        <p>If a tenant had a large block of time at its disposal, and we postulated that it would run an analogous process to the main time bidding process, then what capabilities would we be ascribing to tenants? It is chiefly the ability to synchronously invoke a peer to run for a portion of one's own time such that the peer doesn't notice much difference from a normal invocation. Armed with that ability and guaranteed control of the block of time, the tenant could apply whatever policy it liked to the sub-letting of its time, including the very same policy applied by the VM. The bidding process could be initiated during the block of time, or the pecking order among sub-letters may have been settled in an earlier bidding round.
        <p>This seeming to be in the interests of evolution, we decide that the process by which the VM constructs an invocation environment and runs receiver code for a limited time is also available to tenants. This is the second half of the invocation process, the first being the selection of who will be invoked.
        <p>Another way of looking at this process is that an event-generating tenant could wait for its event to occur, quietly buy a cheap block of processor time and then let the cat out of the bag and run a sub-letting auction amongst its subscribers.
        <p>Generators of events could implement their own subscription system or it could become the speciality of a glade within the family tree of evolved software. The originator of events would then concentrate on finding out what it knows best and simply tell the mailer who would sell it on to multiple subscribers. We could encourage the evolution of these proctime-bidding/mailing schemes by making the built-in scheme unnecessarily wasteful.
        <p>What else distinguishes the VM from any other tenant? ..... TODO
      </div>
      <div title="TODO">
        <p>Reproduction, active mutation, spawning of children wildly different from thier parents, slaves, captives in own VM
        <p>Tree world
        <p>Invocations with roles reversed, multiple messages, privacy
        <p>Multiple blocks per account and vice versa
        <p>Parental relationship
        <p>Tenant-local storage as mini-VM
      </div>
      <div title="The Jungle">
        <p>Nobody said life was fair, and this system will be anything but in its early phases. We can expect abuses like:
        <ol>
          <li>Hardware owners plundering money they hold in trust for their tenants</li>
          <li>Tenants withholdng payments for services already rendered</li>
          <li>Tenants impersonating useful life forms but delivering nothing</li>
          <li>Tenants alerting peers to nothing in order to bankrupt them on processor time bills</li>
        </ol>
        <p>All of these effects are known to the econosphere but don't seem to prevent the system from operating and making progress.
        <p>Accidents, mutations and disasters are necessary to prevent evolution from getting into a rut. All VMs will, at all stages of evolution, randomly select and either kill or corrupt individual tenants from time to time. This might disrupt important value chains but the ecosystem will have to develop its own solutions for that.
        <p>A more earnest problem is the evolution of life forms that run on computers without the owner's permission, i.e. computer viruses that utilise software evolution to generate their own variants. This very serious issue calls for good PR.
        <p>Yet another difficult question is why one would need more than one copy of a given program on a given machine.

      </div>
      <!--
      <div title="Messaging">
        <p>The fourth abuse listed above is the starting point for designing the API on which tenants live. 
        <p>Tenants usually want proctime because of some event arising, e.g. a message from a peer or themselves. 
        <p>Without loss of generality we can use the message as the only means of requesting proctime.
        <p>Routing a message to its receiver costs proctime already, and furthermore, there may be stiff competition for proctime ensuing from popular events such as user interactions.
        <p>This means that a message must be financed before it enters the messaging system. 
        <div title="Sender-driven">
          <p>If we consider the sender to be the party who wants the message to be sent and processed, then it's logical that the sender would pay for the construction, temporary storage, sorting and delivery of the message. 
          <p>Upon delivery, some expense must be incurred while the receiver examines it. Even if the message is uninteresting to the receiver, that fact cannot be ascertained without some expense. Therefore the sender who believes the message to be interesting to the receiver should finance this initial examination as well. On the other hand, the sender does not want to give the receiver a blank cheque to continue purportedly examining the message ad-infinitum. Furthermore, the VM does not want to schedule a potentially infinite proctime window.
          <p>The sender should provide a definite sum of money for the processing of the message. That sum is associated with the message itself and may be referred to as its bank account. The sender will transfer the sum from its own account to the message's account as part of the message generation procedure. The VM will deduct its delivery costs from the message's account and the remainder will finance the receiver's interpretation activities.
          <p>The receiver cannot synchronously extend the finance of the message it is processing because the going rate for proctime might have changed by then. (There is often a queue of tenants eagerly awaiting notification of the same event.) Rather, the receiver can only reserve more proctime by sending itself a message before the current one's finance expires. There is some guesswork involved in deciding how much money to put in a new message, and refined ways of specifying how it should be used may distinguish advanced VM products from one another.
          <p>This mechanism also serves as a payment system: if the receiver yields before the message's finance expires, it keeps the change.
          <p>We've implied that individual tenants have names to which messages may be addressed. These must be unique within a given VM, and presumably globalised by giving the VMs names too. It is advantageous for names to express the pedigree of a tenant, but this is something we can look forward to the evolution of, rather than designing it into the system.
        </div>
        <div title="Prioritisation of sender-driven messages">
          <p>We work on the assumption that the hardware owner aims to tax as much money out of the system as possible. Indeed he should do so in order to consistently aim for Malthusian equilibrium. (He may nevertheless choose to reinvest revenue in the ecosystem using yet-to-be-invented features of future VMs.)
          <p>From the VM's point of view, messaging is about auctioning proctime amongst tenants; priority will go to one of the highest bidders per unit time. Therefore the messages offer the VM a rate per proc cycle. 
          <p>The going rate for proctime is likely to vary wildly according to whether or not anything interesting is going on. So a sender cannot know when a message is likely to be delivered after having offered a certain rate. A very important observation is that some messages will inevitably be discarded because no time ever comes when their offered rate seems attractive, or their interpretation by the receiver might be rudely and prematurely interrupted. This is by no means the only reason why computation in this system is inexact.
        </div>
        <div title="Receiver-driven">
          <p>Tenants need a way to arrange to be invoked when something happens that they specialise in responding to. The obvious model is a set of categorised mailing lists for things like user interaction, system loading levels, etc, but we would also like to see such mailing lists evolve to deal with concepts invented by the tenant society. The simple solution is to allow tenants to create mailing lists of their own. The VM driving the system mailing lists would thus appear to the tenants like any other tenant.   
          <p>In this case it is not the sender (whether VM or tenant) but the receiver who wants the message to get through and who should therefore provide the finance.
          <p>When multiple receivers sign up to the same mailing list, the question of who gets informed first is paramount. This limited resource is to be auctioned like any other, and the beneficiary of the auction is the tenant (or VM) feeding the list. (This is not the only payment model that might evolve between tenants.)
          <p>Clearly, the subscribers to a mailing list must provide finance before interesting events are posted to the list. If nobody has subscribed, then no finance is available for sending a message to the list at all, and we woud not want the system to waste that proctime.
          <p>The subscribers can, of course, compete for priority by providing money up-front annotated by an intended rate per proc cycle.
        </div>
        <div title="Sender-driven-receiver-driven messages">
          <p>The proposed receiver-driven mechanism is verging on offending against the principle of deducing rather than desgning the VM. That can be corrected. Nothing speaks against a tenant implementing a mailing list all by itself using sender-driven messaging. If it did, or if it delegated the functionality to a peer, then the particulars of this mechanism would be subject to evolutionary pressure and development, thus obeying the principle. OTOH, it would seem like a tall order to expect an early life form to just evolve this functionality "by trial and error", and that would be a problem if the lack of the functionality impeded sensible evolution of the ecosystem. 
          <p>A peer that specialised in providing mailing lists would collect funds from subscribers and track an individual bank account for each. The generator of the events would sender-drive a message to the mailer, who would use subscriber funds to sender-drive messages to each. The mailer could, for instance, take a cut from the offered rates and offer the rest to the VM so that the receiver's priority in the eyes of the VM reflected his offer to the mailer. The mailer should observe current proctime rates, bear in mind various overheads and reasonable interpretation times for the receiver, such as to behave in the interests of the receiver. This algorithm is both non-trivial and dependent on the level of culture in the system, making it an ideal candidate for evolution.
          <p>The above paragraph glossed over the money spent by the generator of messages informing the mailer. The provision of these messages is probably the main vocation of the generator and he will expect substantial payment from the mailer for that information. This also applies when the generator is the VM. Generators will shop around for high-paying mailers, and the latter's competitive chances are mainly dependent on the number of subscribers they have. The similarities with human society are striking.
        </div>
        <div title="Messages as Tenants">
          <p>It's worthy of note that tenants and messages have some things in common: both consist of a piece of memory containing some data and an associated bank account. The contents of a tenant are interpreted by the VM while those of a message are interpreted by a tenant. Could a message tell a tenant how to interpret another message? 
          <p>When tenants reproduce they specify the contents of the child. (They may have their own advanced mechanisms for efficient mutation.) It seems unavoidable that an outgoing message will be used to convey the contents of the new child to whatever will create it: usually the VM. In that case, must there be any difference between that message and the child itself? If messages also had names, there would appear to be no further distinction.
          <p>That establishes messaging as the means of reproduction.
        </div>
        <div title="Tenants as VMs">
          <p>When tenants take on the role of tracking bank accounts for other tenants as the hypothetical mailer would, the VM role is eroded. It was not suggested that the VM banking system should know about the banking activities of the mailer, rather, the subscribers would transfer money to the mailer's account up front, and the mailer would casually keep notes on who paid him how much. This is the same as the banking relationship between the VM/owner and ordinary tenants. The owner will hold tenant funds in trust because real banks don't open accounts for computer programs.  
          <p>We have not discovered many distinctions between VM and tenant roles, but the essential difference is that the VM acts as an agent for the hardware owner, the latter being rich amongst peers. The owner has administrator rights on the host system, but most of the available abuses of that right would make him poorer, other than to judge the whole VM useless and destroy it. A rational owner who considered the system lucrative would behave like a tenant. That statement assumes that tenants may sub-let resources to others, hand code them and become the main pressure in their environment, as we may.
          <p>The hardare owner would have no objection to VM roles being taken over by tenants because he can tax all tenants as he sees fit. His potential taxation margins depend on the efficiency of computation, and that can only be improved when tenants attempt to compete with hand-coded VM services.
        </div>
      </div>
      -->
      <div title="The Language">
        <p>What language are these life forms written in? 
        <p>We're rather spoilt for choice. Any language would do, and the usual virtues of coding ease, maintainability and robustness do not apply because no human will be expected to write in it.
        <p>However, we must abandon the concept of a syntax error and similar value judgements. Code will often originate at random and <i>will do something</i> when run. If that something is to crash, that may be the desired behaviour, but there's no particular reason for a great proportion of possible programs to behave in that same way. Rather, the behaviours of programs should be distributed more or less  evenly over the range of writable programs. This is one desideratum for the language to be designed.
        <p>Another is that slight variations of the code should result in slight variations of the behaviour. Random variation of code is our most basic means of creating variants and will dominate until something better evolves.
        <p>Yet another is that it should allow the tenant to perform the essential chores of life. These include:
        <ul>
          <li>Querying one's bank balance</li>
          <li>Quoting one's own code</li>
          <li>Sending messages and payments</li>
          <li>Registering on mailing lists</li>
          <li>Looking for services</li>
          <li>Creating new tenants</li>
          <li>Performing various computations, especially regexes</li>
          <li>Efficient mutation</li>
          <li>Turing completeness</li>
          <li>Etc</li>
        </ul>
        <p>Different VMs may interpret radically different languages but nevertheless evolve similar behaviours when exposed to the same environment and opportunities. The efficiency of computation (and therefore the edge in the evolutionary race) depends strongly on the design of the underlying language and it is primarily on this basis that VMs will compete wth one another. Forth-like langages are pretty fast, and there may even be languages that usually exist as a parsed tree and only linearise themelves for crossing machine boundaries. 
        <p>The code will be run in the context of an incoming message. The particulars of that message, as well as various global barometers and properties of the receiver, must be available in something akin to environment variables. The result of the execution includes the alteration of any properties of the receiver including its code and local variables, and the emmission of messages. The basic life chores might be acomplished by outgoing messages or by some other primitives of the language.
        <p>Many applications will be about text processing so regexes could have a role to play. Regex pattern matching (i.e. excluding substitution syntax) could be augmented like this:
        <ul>
          <li>Characters that evaluate to environment variables</li>
          <li>Submatches captured with round brackets could be routed to named destinations rather than just numbered registers</li>
          <li>Those destinations could be: 
            <ul>
              <li>persistent variables, stacks or queues</li>
              <li>message receivers</li>
              <li>processing pipelines in this same regex-based language</li>
            </ul>
          </li>
        </ul>
        <p>This regex approach is just one of many ways of building a VM.
      </div>
      <div title="Training">
        <p>Whilst trying to avoid 'designing' our desires or expectations into an ecosystem that should evolve freely into a pre-existing world, the system is going to need a few nursery lessons. These might follow a schedule something like this:
        <dl>
          <dt>Reproduce:</dt>
          <dd>Money shower, single clone-with-mutations instruction</dd>
          <dt>...unless you're poor:</dt>
          <dd>Language primitives for balance enquiry, comparison and dice</dd>
          <dt>Talk</dt>
          <dd>Get paid for emitting any message.</dd>
          <dt>Listen</dt>
          <dd>Get paid more for talking to system animals named in messages to you</dd>
          <dt>Invest</dt>
          <dd>Put more money in messages to named peers to get better interest</dd>
          <dt>Cheat</dt>
          <dd>Name yourself to others and fool them into paying you.</dd>
          <dt>Defend</dt>
          <dd>Try investments and remember results. As fools go extinct, so do cheats.</dd>
          <dt>Reward</dt>
          <dd>Get higher interest for larger deposits by pooling fools' contributions, reward fools to keep them alive.</dd>
          <dt>Think</dt>
          <dd>System animals require text processing, (e.g convert-to-upper) for best reward. Breed a large set of transformations.</dd>
          <dt>Etc</dt>
          <dd>Several more stages developing communal processing and encouraging value chains.</dd>
          <dt>Word-completion demo</dt>
          <dd>Simulated SMS scenario where tenants place adverts on screen with their completions. Ad costs money but selection is rewarded in proportion to number of keystrokes saved.</dd>
          <dt>Internet advert placement</dt>
          <dd>This is a very lucrative and directly applicable challenge for such a system.</dd>
        </dl>

      </div>
    </div>
    <div title="Jobs">
      This technology competes with hand coding as a way of generating new software, but it also provides opportunities. One can earn a living in this economy in several ways:
      <dl>
        <dt>Hosting</dt>
        <dd>Buy a specialised box, plug it in and charge rent to tenants. This would appeal to people who tried bitcoin mining, and large players will build data centres.</dd>
        <dt>Farming</dt>
        <dd>A hoster can alter conditions in his VM so as to selectively breed characteristics he thinks will be lucrative in the future. The internet advert placement application will probably lead to an intensive farming race.</dd>
        <dt>VM authoring</dt>
        <dd>Some VMs will outperform others at breeding cutting-edge life forms. A VM with a secret is a saleable commodity. Specific farming efforts can benefit from VM tweaks.</dd>
        <dt>Banking</dt>
        <dd>Banks don't usually process account applications from computer programs, but a specialised type of bank would be better than relying on each hardware owner to hold his tenants' funds in trust. Transactions between VMs must be supported with certain characteristics.</dd>
        <dt>Reverse engineering</dt>
        <dd>It will not be obvious what digital life is thinking, but a new breed of researchers will make it their business to find out.</dd>
      </dl>
    </div>

    <hr/>
    <hr/>
  </div>

  <script>
if (!document.layers)
  document.write('<div id="divStayTopLeft" style="position:absolute">')
  </script>

  <layer id="divStayTopLeft">

  <table id="contentstable" style="border:4 #E0E0E0 solid; cellpadding:1; background-color:#F0F0F0;">

    <script>
function shownumbers(numbers)
{
  var ret="";
  for (var i=0;i<numbers.length;i++) 
  {
    if (ret.length) ret = ret + "." 
      ret = ret + numbers[i];
  }
  return ret;
}

function joinstrings(l)
{
  var ret="";
  for (var i=0;i<l.length;i++) ret+=l[i];
  return ret;
}

function contents(el, numbers)
{
  if (el.nodeType != 1) return;
  if (el.title == "") return;
  el.id=joinstrings(el.title.split(' '));
  document.write("<tr><td>"+shownumbers(numbers)+" . . . <a href=#" + el.id + ">" + el.title + "</a></td></tr>");
  var j=0;
  for (var i=0;i<el.childNodes.length;i++)
  {
    var morenumbers = numbers.slice();
    morenumbers.push(j+1);
    contents(el.childNodes[i], morenumbers);
    if (el.childNodes[i].nodeType==1 && el.childNodes[i].title!="") j++;
  }

  tit=document.createElement("h"+(numbers.length+1));
  titex=document.createTextNode(shownumbers(numbers)+"  "+el.title);
  tit.appendChild(titex);
  el.insertBefore(tit, el.childNodes[0]);

}
contents(document.body.getElementsByTagName("div")[0],[]);
document.body.style.marginLeft = 10+document.getElementById("contentstable").clientWidth;
    </script>

  </table>

  </layer>


  <script type="text/javascript">

/*
Floating Menu script- Roy Whittle (http://www.javascript-fx.com/)
Script featured on/available at http://www.dynamicdrive.com/
This notice must stay intact for use
 */

  var verticalpos="fromtop"

if (!document.layers)
  document.write('</div>')

function JSFX_FloatTopDiv()
{
  var startX = 3,
  startY = 10;
  var ns = (navigator.appName.indexOf("Netscape") != -1);
  var d = document;
  function ml(id)
  {
    //var el=d.getElementById?d.getElementById(id):d.all?d.all[id]:d.layers[id];
    var el=d.getElementById(id);
    if(d.layers)el.style=el;
    el.sP=function(x,y){this.style.left=x;this.style.top=y;};
    el.x = startX;
    if (verticalpos=="fromtop")
      el.y = startY;
    else
    {
      el.y = ns ? pageYOffset + innerHeight : document.body.scrollTop + document.body.clientHeight;
      el.y -= startY;
    }
    return el;
  }
  window.stayTopLeft=function()
  {
    if (verticalpos=="fromtop")
    {
      var pY = ns ? pageYOffset : document.body.scrollTop;
      ftlObj.y += (pY + startY - ftlObj.y)/8;
    }
    else
    {
      var pY = ns ? pageYOffset + innerHeight : document.body.scrollTop + document.body.clientHeight;
      ftlObj.y += (pY - startY - ftlObj.y)/8;
    }
    ftlObj.sP(ftlObj.x, ftlObj.y);
    setTimeout("stayTopLeft()", 10);
  }

  ftlObj = ml("divStayTopLeft");
  stayTopLeft();

}

JSFX_FloatTopDiv();

  </script>

</body>
</ html>
